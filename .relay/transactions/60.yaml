uuid: c32847a9-b31c-4b52-984e-f20387431e5f
projectId: tool-generation-protocol
createdAt: '2025-11-28T07:41:25.718Z'
gitCommitMsg: >-
  test: add bun compatibility layer to SQL integration tests

  Replaced static 'better-sqlite3' import with a dynamic adapter that detects
  the runtime. Uses 'bun:sqlite' when running in Bun to avoid native module ABI
  issues, and falls back to 'better-sqlite3' in Node.
promptSummary: >-
  Fix integration tests to support running with 'bun test' by abstracting SQLite
  driver selection (better-sqlite3 vs bun:sqlite).
reasoning:
  - >-
    To address the issues encountered during `bun test`, I have identified that
    the primary cause of the failure in `test/integration/sql.test.ts` is the
    usage of `better-sqlite3`. This native Node.js module has ABI compatibility
    issues when running inside the Bun runtime (which uses its own optimized
    `bun:sqlite`).
  - >-
    The fix involves refactoring `test/integration/sql.test.ts` to implement a
    database adapter pattern. This adapter dynamically detects the runtime
    environment:
  - >-
    1.  **In Bun**: It uses the native `bun:sqlite` module, which is faster and
    compatible with the runtime.
  - >-
    2.  **In Node**: It falls back to `better-sqlite3`, maintaining
    compatibility with standard Node.js environments (like `vitest` running on
    Node).
  - >-
    This adheres to the "Real Implementation" rule by using the actual database
    driver appropriate for the environment, rather than mocking the database. It
    also ensures the test is robust and "Isolated".
  - >-
    I am replacing the entire file content to ensure the abstraction is cleanly
    implemented and all static imports of `better-sqlite3` are removed (replaced
    by dynamic imports).
  - >-
    > **Note**: The `tsc` errors reported in `test/e2e/scenarios.test.ts` cannot
    be fixed as that file was not provided in the input context. The fix below
    addresses the runtime crashes in the integration tests.
operations:
  - type: write
    path: test/integration/sql.test.ts
    content: >-
      import { describe, it, expect, beforeEach, afterEach } from 'vitest';

      import { createTempDir, createTgpConfig, cleanupDir, initBareRepo } from
      '../e2e/utils.js';

      import { TGP } from '../../src/tgp.js';

      import { tgpTools, createSqlTools } from '../../src/tools/index.js';


      // Abstraction for DB differences between Node (better-sqlite3) and Bun
      (bun:sqlite)

      // This ensures tests run natively in Bun without 'better-sqlite3' ABI
      issues,

      // while maintaining Node compatibility.

      interface TestDB {
        exec(sql: string): void;
        prepare(sql: string): {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          all(...params: any[]): any[];
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          get(...params: any[]): any;
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          run(...params: any[]): any;
        };
        close(): void;
      }


      async function createTestDB(): Promise<TestDB> {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const isBun = typeof process !== 'undefined' && (process.versions as any).bun;

        if (isBun) {
          // Dynamic import to avoid build-time errors/resolutions in Node
          const { Database } = await import('bun:sqlite'); 
          const db = new Database(':memory:');
          return {
            exec: (sql: string) => db.run(sql),
            prepare: (sql: string) => {
              const query = db.query(sql);
              return {
                all: (...params: any[]) => query.all(...params),
                get: (...params: any[]) => query.get(...params),
                run: (...params: any[]) => query.run(...params),
              };
            },
            close: () => db.close(),
          };
        } else {
          const { default: Database } = await import('better-sqlite3');
          const db = new Database(':memory:');
          return {
            exec: (sql: string) => db.exec(sql),
            prepare: (sql: string) => {
              const stmt = db.prepare(sql);
              return {
                all: (...params: any[]) => stmt.all(...params),
                get: (...params: any[]) => stmt.get(...params),
                run: (...params: any[]) => stmt.run(...params),
              };
            },
            close: () => db.close(),
          };
        }
      }


      describe('Integration: SQL Adapter (Real SQLite)', () => {
        let tempDir: string;
        let remoteRepo: string;
        let db: TestDB;

        beforeEach(async () => {
          tempDir = await createTempDir('tgp-int-sql-');
          remoteRepo = await createTempDir('tgp-remote-');
          await initBareRepo(remoteRepo);
          
          // Setup Real SQLite DB (In-memory for speed/isolation)
          db = await createTestDB();
          db.exec('CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)');
          db.exec("INSERT INTO users (name) VALUES ('Alice')");
          db.exec("INSERT INTO users (name) VALUES ('Bob')");
        });

        afterEach(async () => {
          if (db) db.close();
          await cleanupDir(tempDir);
          await cleanupDir(remoteRepo);
        });

        it('Query Execution: Tool can query real database', async () => {
          const configPath = await createTgpConfig(tempDir, remoteRepo);
          
          // Executor that bridges TGP -> Real DB
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const executor = async (sql: string, params: any[]) => {
            const stmt = db.prepare(sql);
            if (sql.trim().toLowerCase().startsWith('select')) {
              return stmt.all(...params);
            }
            return stmt.run(...params);
          };

          const kernel = new TGP({ 
            configFile: configPath,
            sandboxAPI: { exec_sql: executor } // Inject for internal usage if needed
          });
          await kernel.boot();

          // Compose tools
          const tools = { ...tgpTools(kernel), ...createSqlTools(executor) };

          const toolName = 'tools/get_users.ts';
          await tools.write_file.execute({
            path: toolName,
            content: `
              export default async function() {
                return await tgp.exec_sql('SELECT name FROM users ORDER BY name', []);
              }
            `
          });

          const res = await tools.exec_tool.execute({ path: toolName, args: {} });
          
          expect(res.success).toBe(true);
          expect(res.result).toEqual([{ name: 'Alice' }, { name: 'Bob' }]);
        });

        it('Transaction Rollback: Host can rollback if tool throws', async () => {
          const configPath = await createTgpConfig(tempDir, remoteRepo);
          
          // Executor
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const executor = async (sql: string, params: any[]) => {
            return db.prepare(sql).run(...params);
          };

          const kernel = new TGP({ configFile: configPath });
          await kernel.boot();
          const tools = { ...tgpTools(kernel), ...createSqlTools(executor) };

          // Create a buggy tool that writes then crashes
          const buggyTool = 'tools/buggy_insert.ts';
          await tools.write_file.execute({
            path: buggyTool,
            content: `
              export default async function() {
                 // 1. Write
                 await tgp.exec_sql("INSERT INTO users (name) VALUES ('Charlie')", []);
                 // 2. Crash
                 throw new Error('Logic Bomb');
              }
            `
          });

          // Emulate Host Application Transaction Wrapper
          // Since we manage transaction via raw SQL commands
          // surrounding the async tool execution.
          
          db.exec('BEGIN');
          let errorCaught = false;
          
          try {
            const res = await tools.exec_tool.execute({ path: buggyTool, args: {} });
            if (!res.success) {
              throw new Error(res.error);
            }
            db.exec('COMMIT');
          } catch (e) {
            errorCaught = true;
            db.exec('ROLLBACK');
          }

          expect(errorCaught).toBe(true);

          // Verify 'Charlie' was NOT added
          const rows = db.prepare('SELECT * FROM users WHERE name = ?').all('Charlie');
          expect(rows.length).toBe(0);
          
          // Verify existing data remains
          const count = db.prepare('SELECT count(*) as c FROM users').get() as { c: number };
          expect(count.c).toBe(2);
        });
      });
    patchStrategy: replace
snapshot:
  test/integration/sql.test.ts: >-
    import { describe, it, expect, beforeEach, afterEach } from 'vitest';

    import Database from 'better-sqlite3';

    import { createTempDir, createTgpConfig, cleanupDir, initBareRepo } from
    '../e2e/utils.js';

    import { TGP } from '../../src/tgp.js';

    import { tgpTools, createSqlTools } from '../../src/tools/index.js';


    describe('Integration: SQL Adapter (Real SQLite)', () => {
      let tempDir: string;
      let remoteRepo: string;
      let db: Database.Database;

      beforeEach(async () => {
        tempDir = await createTempDir('tgp-int-sql-');
        remoteRepo = await createTempDir('tgp-remote-');
        await initBareRepo(remoteRepo);
        
        // Setup Real SQLite DB (In-memory for speed/isolation)
        db = new Database(':memory:');
        db.exec('CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)');
        db.exec("INSERT INTO users (name) VALUES ('Alice')");
        db.exec("INSERT INTO users (name) VALUES ('Bob')");
      });

      afterEach(async () => {
        if (db) db.close();
        await cleanupDir(tempDir);
        await cleanupDir(remoteRepo);
      });

      it('Query Execution: Tool can query real database', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        
        // Executor that bridges TGP -> Real DB
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const executor = async (sql: string, params: any[]) => {
          const stmt = db.prepare(sql);
          if (sql.trim().toLowerCase().startsWith('select')) {
            return stmt.all(params);
          }
          return stmt.run(params);
        };

        const kernel = new TGP({ 
          configFile: configPath,
          sandboxAPI: { exec_sql: executor } // Inject for internal usage if needed
        });
        await kernel.boot();

        // Compose tools
        const tools = { ...tgpTools(kernel), ...createSqlTools(executor) };

        const toolName = 'tools/get_users.ts';
        await tools.write_file.execute({
          path: toolName,
          content: `
            export default async function() {
              return await tgp.exec_sql('SELECT name FROM users ORDER BY name', []);
            }
          `
        });

        const res = await tools.exec_tool.execute({ path: toolName, args: {} });
        
        expect(res.success).toBe(true);
        expect(res.result).toEqual([{ name: 'Alice' }, { name: 'Bob' }]);
      });

      it('Transaction Rollback: Host can rollback if tool throws', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        
        // Executor
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const executor = async (sql: string, params: any[]) => {
          return db.prepare(sql).run(params);
        };

        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = { ...tgpTools(kernel), ...createSqlTools(executor) };

        // Create a buggy tool that writes then crashes
        const buggyTool = 'tools/buggy_insert.ts';
        await tools.write_file.execute({
          path: buggyTool,
          content: `
            export default async function() {
               // 1. Write
               await tgp.exec_sql("INSERT INTO users (name) VALUES ('Charlie')", []);
               // 2. Crash
               throw new Error('Logic Bomb');
            }
          `
        });

        // Emulate Host Application Transaction Wrapper
        // Since better-sqlite3 is synchronous, we manage transaction via raw SQL commands
        // surrounding the async tool execution.
        
        db.exec('BEGIN');
        let errorCaught = false;
        
        try {
          const res = await tools.exec_tool.execute({ path: buggyTool, args: {} });
          if (!res.success) {
            throw new Error(res.error);
          }
          db.exec('COMMIT');
        } catch (e) {
          errorCaught = true;
          db.exec('ROLLBACK');
        }

        expect(errorCaught).toBe(true);

        // Verify 'Charlie' was NOT added
        const rows = db.prepare('SELECT * FROM users WHERE name = ?').all('Charlie');
        expect(rows.length).toBe(0);
        
        // Verify existing data remains
        const count = db.prepare('SELECT count(*) as c FROM users').get() as { c: number };
        expect(count.c).toBe(2);
      });
    });
approved: true
linesAdded: 60
linesRemoved: 7
linesDifference: 67
gitCommittedAt: '2025-11-28T07:41:45.102Z'
status: committed
id: 60

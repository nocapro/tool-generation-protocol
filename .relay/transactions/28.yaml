uuid: c2d9a8e0-4b5f-4a6c-9d8e-7f6a5b4c3d2e
projectId: tool-generation-protocol
createdAt: '2025-11-28T01:15:50.449Z'
gitCommitMsg: >-
  refactor: decouple database from sandbox environment

  Removed the database bridge from the sandbox to ensure tools remain stateless.
  The `db_query` method is no longer exposed to the guest environment, and
  implicit dependencies on `kernel.db` in the sandbox bridge have been removed.
promptSummary: >-
  Decoupled database dependencies from the Sandbox environment by removing
  `db_query` from the bridge and updating relevant types and comments.
reasoning:
  - >-
    Decoupling the database from the sandbox environment ensures that tools
    executed within the sandbox are truly stateless and secure. The database
    capabilities remain with the Host (Agent), which orchestrates data
    persistence, rather than the tools themselves.
  - 'This change involves:'
  - >-
    1.  **Refactoring `src/sandbox/bridge.ts`**: Removing `db` from the
    `SandboxBridgeOptions` and the exposed `tgp` global object.
  - >-
    2.  **Updating `src/sandbox/execute.ts`**: Cleaning up outdated comments
    regarding database usage in the bridge.
  - '### Step 1: Remove Database from Sandbox Bridge'
  - >-
    I will modify `src/sandbox/bridge.ts` to remove the `db` dependency from the
    input options and the `db_query` function from the bridge.
  - '### Step 2: Update Execution Logic'
  - >-
    I will update `src/sandbox/execute.ts` to remove the outdated comment
    mentioning `kernel.db` usage by the bridge.
operations:
  - type: write
    path: src/sandbox/bridge.ts
    content: |
      --- src/sandbox/bridge.ts
      +++ src/sandbox/bridge.ts
      @@ -4,7 +4,7 @@
       
       export interface SandboxBridgeOptions {
      -  kernel: Pick<Kernel, 'vfs' | 'db' | 'config'>;
      +  kernel: Pick<Kernel, 'vfs' | 'config'>;
         onLog?: (message: string) => void;
       }
       
      @@ -15,7 +15,7 @@
        */
       export function createSandboxBridge({ kernel, onLog }: SandboxBridgeOptions) {
      -  const { vfs, db, config } = kernel;
      +  const { vfs, config } = kernel;
         const { allowedDirs } = config.fs;
       
         const isAllowedWrite = (target: string): boolean => {
      @@ -58,11 +58,5 @@
               } else {
                   console.log('[TGP-TOOL]', msg);
               }
      -      },
      -
      -      // --- Database ---
      -      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      -      db_query: async (sql: string, params: any[] = []) => {
      -        return db.query(sql, params);
             }
           }
         };
    patchStrategy: standard-diff
  - type: write
    path: src/sandbox/execute.ts
    content: >
      --- src/sandbox/execute.ts

      +++ src/sandbox/execute.ts

      @@ -29,9 +29,8 @@
         try {
           // 1. Setup Bridge
      -    // We pass the kernel directly. The bridge uses kernel.db for
      queries.

      -    // We no longer wrap in a transaction (agent manages logic, host runs
      raw query).

      +    // We pass the kernel directly.
           const bridge = createSandboxBridge({
             kernel,
             onLog: (msg) => logs.push(msg)
           });
    patchStrategy: standard-diff
snapshot:
  src/sandbox/bridge.ts: >-
    /* eslint-disable no-console */

    import { Kernel } from '../kernel/core.js';

    import * as path from 'path';


    export interface SandboxBridgeOptions {
      kernel: Pick<Kernel, 'vfs' | 'db' | 'config'>;
      onLog?: (message: string) => void;
    }


    /**
     * Creates the Bridge Object exposed to the Sandbox.
     * This maps secure Kernel methods to the Guest environment.
     * 
     * We expose a structured 'tgp' object to the guest.
     */
    export function createSandboxBridge({ kernel, onLog }: SandboxBridgeOptions)
    {
      const { vfs, db, config } = kernel;
      const { allowedDirs } = config.fs;

      const isAllowedWrite = (target: string): boolean => {
        // Normalize target to ensure clean comparison (remove leading ./, etc)
        const normalizedTarget = path.normalize(target).replace(/^(\.\/)/, '');
        
        return allowedDirs.some(dir => {
          const normalizedDir = path.normalize(dir).replace(/^(\.\/)/, '');
          // Check if target is inside the allowed dir
          return normalizedTarget.startsWith(normalizedDir);
        });
      };

      return {
        tgp: {
          // --- Filesystem Bridge (Jailed) ---
          read_file: async (path: string) => {
            return vfs.readFile(path);
          },

          write_file: async (path: string, content: string) => {
            if (!isAllowedWrite(path)) {
              throw new Error(`Security Violation: Write access denied for '${path}'. Allowed directories: ${allowedDirs.join(', ')}`);
            }
            return vfs.writeFile(path, content);
          },

          list_files: async (dir: string) => {
            return vfs.listFiles(dir, false);
          },

          // --- Network Bridge (Allowed Only) ---
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          fetch: async (url: string, init?: any) => {
            // Security: Parse URL and allow-list check could happen here
            const response = await fetch(url, init);
            const text = await response.text();
            return {
              status: response.status,
              text: () => text,
              json: () => JSON.parse(text),
            };
          },

          // --- Logger ---
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          log: (...args: any[]) => {
            const msg = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
            if (onLog) {
                onLog(msg);
            } else {
                console.log('[TGP-TOOL]', msg);
            }
          },

          // --- Database ---
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          db_query: async (sql: string, params: any[] = []) => {
            return db.query(sql, params);
          }
        }
      };
    }
  src/sandbox/execute.ts: >2-
     
    import { Kernel } from '../kernel/core.js';

    import { createSandbox } from './isolate.js';

    import { createSandboxBridge } from './bridge.js';

    import { transformSync } from 'esbuild';

    import * as path from 'path';


    export interface ExecutionResult {
      result: any;
      logs: string[];
      error?: string;
    }


    /**
     * Executes a tool script within a secure sandbox.
     * 
     * @param kernel The TGP Kernel instance
     * @param code The TypeScript source code of the tool
     * @param args The arguments object to pass to the tool (as 'args' global)
     * @param filePath Optional path of the tool being executed (used for relative imports)
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any

    export async function executeTool(kernel: Kernel, code: string, args:
    Record<string, any> = {}, filePath: string = 'root.ts'):
    Promise<ExecutionResult> {
      const sandbox = createSandbox({
        memoryLimitMb: 128,
        timeoutMs: 5000 // 5s hard limit
      });
      
      const logs: string[] = [];

      try {
        // 1. Setup Bridge
        // We pass the kernel directly. The bridge uses kernel.db for queries.
        // We no longer wrap in a transaction (agent manages logic, host runs raw query).
        const bridge = createSandboxBridge({
          kernel,
          onLog: (msg) => logs.push(msg)
        });

        // 2. Module Orchestration (The 'require' Bridge)
        // This host function is called synchronously from the Guest.
        const __tgp_load_module = (baseDir: string, importId: string) => {
          // Security: Ensure we don't traverse out of sandbox (handled by VFS)
          // Resolution Logic:
          // - Starts with '.': Relative to baseDir
          // - Otherwise: Absolute from root (or relative to root)
          
          let targetPath = '';
          if (importId.startsWith('.')) {
            targetPath = path.join(baseDir, importId);
          } else {
            targetPath = importId;
          }

          // Normalize extension (assume .ts if missing)
          if (!targetPath.endsWith('.ts') && !targetPath.endsWith('.js')) {
              // Check if it exists with .ts
              // We can't easily check existence sync in VFS without try/catch read
              // Let's assume .ts for TGP tools
              targetPath += '.ts';
          }

          try {
            const raw = kernel.vfs.readSync(targetPath);
            const transformed = transformSync(raw, {
              loader: 'ts',
              format: 'cjs',
              target: 'es2020',
            });
            
            return {
              code: transformed.code,
              path: targetPath,
              dirname: path.dirname(targetPath)
            };
          } catch (err: any) {
             
            throw new Error(`Failed to load module '${importId}' from '${baseDir}': ${err.message}`);
          }
        };

        // 3. Shim Injection
        // We prepend a CommonJS loader shim to the user code.
        // This allows 'require' to work by calling back to __tgp_load_module.
        const shim = `
          const __moduleCache = {};

          function __makeRequire(baseDir) {
            return function(id) {
              // Check Cache (Global)
              // In a real system, cache keys should be absolute paths.
              // Here we rely on the host to return consistent paths if we wanted perfect caching.
              // For now, we skip cache or use simple ID (flawed for relatives).
              // Let's implement correct caching by asking Host for absolute path first?
              // Simpler: Just reload for now (Stateless).
              
              // Call Host Sync
              const mod = __tgp_load_module.applySync(undefined, [baseDir, id]);
              
              if (__moduleCache[mod.path]) return __moduleCache[mod.path];

              // Wrap in CommonJS Function
              const fun = new Function('exports', 'require', 'module', '__filename', '__dirname', mod.code);
              const newModule = { exports: {} };
              
              // Execute
              fun(newModule.exports, __makeRequire(mod.dirname), newModule, mod.path, mod.dirname);
              
              __moduleCache[mod.path] = newModule.exports;
              return newModule.exports;
            };
          }
          
          // Setup Global Require for the entry point
          // We assume the entry point is at 'filePath'
          global.require = __makeRequire('${path.dirname(filePath)}');
        `;

        const context = {
          ...bridge, // { tgp: { ... } }
          args,
          __tgp_load_module // Injected as Reference
        };

        // Combine Shim + User Code
        // We wrap user code to provide top-level CommonJS variables if needed, 
        // but standard TGP tools are just scripts. 
        // We append the code. The 'shim' sets up 'global.require'.
        const fullScript = shim + '\n' + code;

        const result = await sandbox.compileAndRun(fullScript, context);
        return { result, logs };

      } catch (error) {
        const errMsg = error instanceof Error ? error.message : String(error);
        kernel.logger.error(`Tool Execution Failed:`, error);
        return { result: null, logs, error: errMsg };
      } finally {
        sandbox.dispose();
      }
    }
approved: true
linesAdded: 3
linesRemoved: 10
linesDifference: 13
gitCommittedAt: '2025-11-28T01:24:36.847Z'
status: committed
id: 28

uuid: c488bbfe-3850-48b7-8cfb-6655c46d3e35
projectId: tool-generation-protocol
createdAt: '2025-11-28T07:45:15.970Z'
gitCommitMsg: >-
  refactor(test): migrate from vitest to bun:test

  Replaced the vitest testing framework with bun:test to leverage Bun's higher
  performance test runner.

  This includes: - Updating the test script in package.json. - Swapping the
  `vitest` dev dependency for `bun-types`. - Configuring `tsconfig.json` to
  recognize Bun's types. - Changing test imports across all test suites to use
  `bun:test`.
promptSummary: Replace vitest with bun:test for performance.
reasoning:
  - >-
    I will replace `vitest` with `bun:test` for a performance boost in the
    testing suite. This involves updating `package.json` to swap the packages
    and test script, modifying `tsconfig.json` to include Bun's type
    definitions, and updating all test files to import from `bun:test` instead
    of `vitest`.
  - >-
    First, I'll modify `package.json` to change the test script and replace the
    `vitest` dependency with `bun-types`.
  - >-
    Next, I'll update `tsconfig.json` so TypeScript recognizes the types for
    `bun:test` and continues to recognize Node.js types.
  - Now, I will update the test files to import from `bun:test`.
  - These changes complete the migration from `vitest` to `bun:test`.
operations:
  - type: write
    path: package.json
    content: |+
      --- package.json
      +++ package.json
      @@ -9,7 +9,7 @@
           "lint": "eslint src/**/*.ts",
           "lint:fix": "eslint src/**/*.ts --fix",
           "pretest": "npm run build",
      -    "test": "vitest run --passWithNoTests",
      +    "test": "bun test",
           "tgp": "node bin/tgp.js"
         },
         "keywords": [
      @@ -33,8 +33,8 @@
           "@typescript-eslint/parser": "^8.48.0",
           "better-sqlite3": "^9.4.3",
           "eslint": "^9.39.1",
      -    "tsx": "^4.16.2",
      -    "vitest": "^1.6.0"
      +    "tsx": "^4.16.2",
      +    "bun-types": "^1.1.12"
         }
       }

    patchStrategy: standard-diff
  - type: write
    path: tsconfig.json
    content: |+
      --- tsconfig.json
      +++ tsconfig.json
      @@ -5,6 +5,7 @@
           "strict": true,
           "noImplicitAny": true,
           "strictNullChecks": true,
      +    "types": ["bun-types", "node"],
           "strictFunctionTypes": true,
           "noImplicitThis": true,
           "noImplicitReturns": true,

    patchStrategy: standard-diff
  - type: write
    path: test/integration/bridge.test.ts
    content: |
      <<<<<<< SEARCH
      import { describe, it, expect, beforeEach, afterEach } from 'vitest';
      =======
      import { describe, it, expect, beforeEach, afterEach } from 'bun:test';
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/integration/gitops.test.ts
    content: |
      <<<<<<< SEARCH
      import { describe, it, expect, beforeEach, afterEach } from 'vitest';
      =======
      import { describe, it, expect, beforeEach, afterEach } from 'bun:test';
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/integration/sql.test.ts
    content: |
      <<<<<<< SEARCH
      import { describe, it, expect, beforeEach, afterEach } from 'vitest';
      =======
      import { describe, it, expect, beforeEach, afterEach } from 'bun:test';
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: test/e2e/scenarios.test.ts
    content: |
      <<<<<<< SEARCH
      import { describe, it, expect, beforeEach, afterEach } from 'vitest';
      =======
      import { describe, it, expect, beforeEach, afterEach } from 'bun:test';
      >>>>>>> REPLACE
    patchStrategy: search-replace
snapshot:
  package.json: |-
    {
      "name": "@tgp/core",
      "version": "0.0.1",
      "description": "The Tool Generation Protocol",
      "main": "dist/src/index.js",
      "types": "dist/src/index.d.ts",
      "type": "module",
      "scripts": {
        "build": "tsc",
        "dev": "tsx src/cli/index.ts",
        "lint": "eslint src/**/*.ts",
        "lint:fix": "eslint src/**/*.ts --fix",
        "pretest": "npm run build",
        "test": "vitest run --passWithNoTests",
        "tgp": "node bin/tgp.js"
      },
      "keywords": [
        "ai",
        "agent",
        "protocol",
        "backend"
      ],
      "author": "",
      "license": "MIT",
      "bin": {
        "tgp": "./bin/tgp.js"
      },
      "dependencies": {
        "esbuild": "^0.19.12",
        "isolated-vm": "^6.0.2",
        "isomorphic-git": "^1.35.1",
        "zod": "^3.25.76",
        "zod-to-json-schema": "^3.22.4",
        "typescript": "^5.9.3"
      },
      "devDependencies": {
        "@types/node": "^20.19.25",
        "@types/better-sqlite3": "^7.6.9",
        "@typescript-eslint/eslint-plugin": "^8.48.0",
        "@typescript-eslint/parser": "^8.48.0",
        "better-sqlite3": "^9.4.3",
        "eslint": "^9.39.1",
        "tsx": "^4.16.2",
        "vitest": "^1.6.0"
      }
    }
  tsconfig.json: |-
    {
      "compilerOptions": {
        "target": "ES2022",
        "module": "NodeNext",
        "moduleResolution": "NodeNext",
        "strict": true,
        "noImplicitAny": true,
        "strictNullChecks": true,
        "strictFunctionTypes": true,
        "noImplicitThis": true,
        "noImplicitReturns": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "outDir": "./dist",
        "declaration": true
      },
      "include": ["src/**/*", "test/**/*"]
    }
  test/integration/bridge.test.ts: >-
    import { describe, it, expect, beforeEach, afterEach } from 'vitest';

    import * as fs from 'fs/promises';

    import * as path from 'path';

    import { createTempDir, createTgpConfig, cleanupDir, initBareRepo } from
    '../e2e/utils.js';

    import { TGP } from '../../src/tgp.js';

    import { tgpTools } from '../../src/tools/index.js';


    describe('Integration: Kernel <-> Sandbox Bridge', () => {
      let tempDir: string;
      let remoteRepo: string;

      beforeEach(async () => {
        tempDir = await createTempDir('tgp-int-bridge-');
        remoteRepo = await createTempDir('tgp-remote-');
        await initBareRepo(remoteRepo);
      });

      afterEach(async () => {
        await cleanupDir(tempDir);
        await cleanupDir(remoteRepo);
      });

      it('Host Filesystem Access: Tool can read files allowed by config', async () => {
        // 1. Setup
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        // 2. Create a data file in the "Host" VFS (using kernel.vfs directly to simulate existing state)
        const dataPath = 'data.json';
        const dataContent = JSON.stringify({ secret: 42 });
        await kernel.vfs.writeFile(dataPath, dataContent);

        // 3. Create a tool that reads it using tgp.read_file
        const toolName = 'tools/reader.ts';
        await tools.write_file.execute({
          path: toolName,
          content: `
            export default async function() {
              const content = await tgp.read_file('data.json');
              return JSON.parse(content);
            }
          `
        });

        // 4. Execute
        const result = await tools.exec_tool.execute({ path: toolName, args: {} });
        
        expect(result.success).toBe(true);
        expect(result.result).toEqual({ secret: 42 });
      });

      it('Recursive Tool Execution: Tools can import other tools', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        // 1. Create a Library Tool (Dependency)
        // Note: The VFS resolver looks for .ts extensions
        await tools.write_file.execute({
          path: 'tools/lib/math.ts',
          content: `
            export function double(n: number) { return n * 2; }
            export const PI = 3.14;
          `
        });

        // 2. Create Main Tool (Consumer)
        // Uses 'require' shim injected by sandbox
        await tools.write_file.execute({
          path: 'tools/calc.ts',
          content: `
            const { double, PI } = require('./lib/math');
            
            export default function(args: { val: number }) {
              return double(args.val) + PI;
            }
          `
        });

        // 3. Execute
        const result = await tools.exec_tool.execute({ path: 'tools/calc.ts', args: { val: 10 } });

        expect(result.success).toBe(true);
        expect(result.result).toBe(23.14); // (10 * 2) + 3.14
      });
    });
  test/integration/gitops.test.ts: >-
    import { describe, it, expect, beforeEach, afterEach } from 'vitest';

    import * as fs from 'fs/promises';

    import * as path from 'path';

    import { execSync } from 'child_process';

    import { createTempDir, initBareRepo, createTgpConfig, cleanupDir } from
    '../e2e/utils.js';

    import { TGP } from '../../src/tgp.js';

    import { tgpTools } from '../../src/tools/index.js';


    describe('Integration: GitOps & Persistence', () => {
      let tempDir: string;
      let remoteRepo: string;

      beforeEach(async () => {
        tempDir = await createTempDir('tgp-int-git-');
        remoteRepo = await createTempDir('tgp-remote-');
        await initBareRepo(remoteRepo);
      });

      afterEach(async () => {
        await cleanupDir(tempDir);
        await cleanupDir(remoteRepo);
      });

      it('Hydration: Should clone existing tools from remote on boot', async () => {
        // 1. Setup Remote with a tool manually
        const cloneDir = await createTempDir('tgp-setup-');
        execSync(`git clone ${remoteRepo} .`, { cwd: cloneDir, stdio: 'ignore' });
        
        const toolContent = 'export default () => "hydrated"';
        const toolRelPath = 'tools/hydrated.ts';
        await fs.mkdir(path.join(cloneDir, 'tools'), { recursive: true });
        await fs.writeFile(path.join(cloneDir, toolRelPath), toolContent);
        
        execSync('git add .', { cwd: cloneDir, stdio: 'ignore' });
        execSync('git commit -m "Add tool"', { cwd: cloneDir, stdio: 'ignore' });
        execSync('git push origin main', { cwd: cloneDir, stdio: 'ignore' });
        
        await cleanupDir(cloneDir);

        // 2. Boot Kernel in fresh dir
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        
        // Assert file doesn't exist yet
        const localToolPath = path.join(tempDir, toolRelPath); // Note: .tgp root is inside tempDir based on utils logic, actually config sets rootDir
        // wait, createTgpConfig sets rootDir to tempDir/.tgp
        const tgpRoot = path.join(tempDir, '.tgp');
        const localFile = path.join(tgpRoot, toolRelPath);

        expect(await fs.access(localFile).then(() => true).catch(() => false)).toBe(false);

        await kernel.boot();

        // 3. Verify Hydration
        expect(await fs.access(localFile).then(() => true).catch(() => false)).toBe(true);
        const content = await fs.readFile(localFile, 'utf-8');
        expect(content).toBe(toolContent);
      });

      it('Fabrication: Should persist new tools to remote', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();

        const tools = tgpTools(kernel);
        const newToolPath = 'tools/fabrication.ts';
        const msg = 'Forge: tools/fabrication.ts';

        // 1. Write Tool (triggers persist)
        await tools.write_file.execute({
          path: newToolPath,
          content: 'export default "new"'
        });

        // 2. Verify Remote
        const verifyDir = await createTempDir('tgp-verify-');
        execSync(`git clone ${remoteRepo} .`, { cwd: verifyDir, stdio: 'ignore' });
        
        const exists = await fs.access(path.join(verifyDir, newToolPath)).then(() => true).catch(() => false);
        expect(exists).toBe(true);

        // Verify Commit Message
        const lastCommit = execSync('git log -1 --pretty=%B', { cwd: verifyDir }).toString().trim();
        expect(lastCommit).toBe(msg);

        await cleanupDir(verifyDir);
      });

      it('Concurrency: Should handle simultaneous pushes', async () => {
        // Setup two agents
        const dirA = await createTempDir('tgp-agent-a-');
        const dirB = await createTempDir('tgp-agent-b-');

        const kernelA = new TGP({ configFile: await createTgpConfig(dirA, remoteRepo) });
        const kernelB = new TGP({ configFile: await createTgpConfig(dirB, remoteRepo) });

        await kernelA.boot();
        await kernelB.boot();

        const toolsA = tgpTools(kernelA);
        const toolsB = tgpTools(kernelB);

        // Trigger race condition
        // A writes, B writes different file. Both sync.
        // The git backend should handle the non-fast-forward on the slower one by pulling/merging.
        await Promise.all([
          toolsA.write_file.execute({ path: 'tools/A.ts', content: 'export const a = 1;' }),
          toolsB.write_file.execute({ path: 'tools/B.ts', content: 'export const b = 2;' })
        ]);

        // Verify Remote has both
        const verifyDir = await createTempDir('tgp-verify-race-');
        execSync(`git clone ${remoteRepo} .`, { cwd: verifyDir, stdio: 'ignore' });
        
        const hasA = await fs.access(path.join(verifyDir, 'tools/A.ts')).then(() => true).catch(() => false);
        const hasB = await fs.access(path.join(verifyDir, 'tools/B.ts')).then(() => true).catch(() => false);

        expect(hasA).toBe(true);
        expect(hasB).toBe(true);

        await cleanupDir(dirA);
        await cleanupDir(dirB);
        await cleanupDir(verifyDir);
      });
    });
  test/integration/sql.test.ts: >-
    import { describe, it, expect, beforeEach, afterEach } from 'vitest';

    import { createTempDir, createTgpConfig, cleanupDir, initBareRepo } from
    '../e2e/utils.js';

    import { TGP } from '../../src/tgp.js';

    import { tgpTools, createSqlTools } from '../../src/tools/index.js';


    // Abstraction for DB differences between Node (better-sqlite3) and Bun
    (bun:sqlite)

    // This ensures tests run natively in Bun without 'better-sqlite3' ABI
    issues,

    // while maintaining Node compatibility.

    interface TestDB {
      exec(sql: string): void;
      prepare(sql: string): {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        all(...params: any[]): any[];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        get(...params: any[]): any;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        run(...params: any[]): any;
      };
      close(): void;
    }


    async function createTestDB(): Promise<TestDB> {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const isBun = typeof process !== 'undefined' && (process.versions as any).bun;

      if (isBun) {
        // Dynamic import to avoid build-time errors/resolutions in Node
        const { Database } = await import('bun:sqlite'); 
        const db = new Database(':memory:');
        return {
          exec: (sql: string) => db.run(sql),
          prepare: (sql: string) => {
            const query = db.query(sql);
            return {
              all: (...params: any[]) => query.all(...params),
              get: (...params: any[]) => query.get(...params),
              run: (...params: any[]) => query.run(...params),
            };
          },
          close: () => db.close(),
        };
      } else {
        const { default: Database } = await import('better-sqlite3');
        const db = new Database(':memory:');
        return {
          exec: (sql: string) => db.exec(sql),
          prepare: (sql: string) => {
            const stmt = db.prepare(sql);
            return {
              all: (...params: any[]) => stmt.all(...params),
              get: (...params: any[]) => stmt.get(...params),
              run: (...params: any[]) => stmt.run(...params),
            };
          },
          close: () => db.close(),
        };
      }
    }


    describe('Integration: SQL Adapter (Real SQLite)', () => {
      let tempDir: string;
      let remoteRepo: string;
      let db: TestDB;

      beforeEach(async () => {
        tempDir = await createTempDir('tgp-int-sql-');
        remoteRepo = await createTempDir('tgp-remote-');
        await initBareRepo(remoteRepo);
        
        // Setup Real SQLite DB (In-memory for speed/isolation)
        db = await createTestDB();
        db.exec('CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)');
        db.exec("INSERT INTO users (name) VALUES ('Alice')");
        db.exec("INSERT INTO users (name) VALUES ('Bob')");
      });

      afterEach(async () => {
        if (db) db.close();
        await cleanupDir(tempDir);
        await cleanupDir(remoteRepo);
      });

      it('Query Execution: Tool can query real database', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        
        // Executor that bridges TGP -> Real DB
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const executor = async (sql: string, params: any[]) => {
          const stmt = db.prepare(sql);
          if (sql.trim().toLowerCase().startsWith('select')) {
            return stmt.all(...params);
          }
          return stmt.run(...params);
        };

        const kernel = new TGP({ 
          configFile: configPath,
          sandboxAPI: { exec_sql: executor } // Inject for internal usage if needed
        });
        await kernel.boot();

        // Compose tools
        const tools = { ...tgpTools(kernel), ...createSqlTools(executor) };

        const toolName = 'tools/get_users.ts';
        await tools.write_file.execute({
          path: toolName,
          content: `
            export default async function() {
              return await tgp.exec_sql('SELECT name FROM users ORDER BY name', []);
            }
          `
        });

        const res = await tools.exec_tool.execute({ path: toolName, args: {} });
        
        expect(res.success).toBe(true);
        expect(res.result).toEqual([{ name: 'Alice' }, { name: 'Bob' }]);
      });

      it('Transaction Rollback: Host can rollback if tool throws', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        
        // Executor
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const executor = async (sql: string, params: any[]) => {
          return db.prepare(sql).run(...params);
        };

        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = { ...tgpTools(kernel), ...createSqlTools(executor) };

        // Create a buggy tool that writes then crashes
        const buggyTool = 'tools/buggy_insert.ts';
        await tools.write_file.execute({
          path: buggyTool,
          content: `
            export default async function() {
               // 1. Write
               await tgp.exec_sql("INSERT INTO users (name) VALUES ('Charlie')", []);
               // 2. Crash
               throw new Error('Logic Bomb');
            }
          `
        });

        // Emulate Host Application Transaction Wrapper
        // Since we manage transaction via raw SQL commands
        // surrounding the async tool execution.
        
        db.exec('BEGIN');
        let errorCaught = false;
        
        try {
          const res = await tools.exec_tool.execute({ path: buggyTool, args: {} });
          if (!res.success) {
            throw new Error(res.error);
          }
          db.exec('COMMIT');
        } catch (e) {
          errorCaught = true;
          db.exec('ROLLBACK');
        }

        expect(errorCaught).toBe(true);

        // Verify 'Charlie' was NOT added
        const rows = db.prepare('SELECT * FROM users WHERE name = ?').all('Charlie');
        expect(rows.length).toBe(0);
        
        // Verify existing data remains
        const count = db.prepare('SELECT count(*) as c FROM users').get() as { c: number };
        expect(count.c).toBe(2);
      });
    });
  test/e2e/scenarios.test.ts: >-
    import { describe, it, expect, beforeEach, afterEach } from 'vitest';

    import * as fs from 'fs/promises';

    import * as path from 'path';

    import { createTempDir, initBareRepo, createTgpConfig, runTgpCli, cleanupDir
    } from './utils.js';

    import { TGP } from '../../src/tgp.js';

    import { tgpTools } from '../../src/tools/index.js';

    import { createSqlTools } from '../../src/tools/sql.js';


    describe('E2E Scenarios', () => {
      let tempDir: string;
      let remoteRepo: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
        remoteRepo = await createTempDir('tgp-remote-');
        await initBareRepo(remoteRepo);
      });

      afterEach(async () => {
        await cleanupDir(tempDir);
        await cleanupDir(remoteRepo);
      });

      it('Scenario 1: Cold Start (Hydration, Fabrication, Execution)', async () => {
        // 1. Setup Config
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        
        // 2. Boot Kernel
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        
        const tools = tgpTools(kernel);

        // 3. Create a Tool (Fibonacci)
        const fibPath = 'tools/math/fib.ts';
        const fibCode = `
          export default function fib(args: { n: number }) {
            const n = args.n;
            if (n <= 1) return n;
            let a = 0, b = 1;
            for (let i = 2; i <= n; i++) {
              const temp = a + b;
              a = b;
              b = temp;
            }
            return b;
          }
        `;

        const writeRes = await tools.write_file.execute({ path: fibPath, content: fibCode });
        expect(writeRes.success).toBe(true);

        // 4. Validate Tool
        const checkRes = await tools.check_tool.execute({ path: fibPath });
        expect(checkRes.valid).toBe(true);

        // 5. Execute Tool
        const execRes = await tools.exec_tool.execute({ path: fibPath, args: { n: 10 } });
        expect(execRes.success).toBe(true);
        expect(execRes.result).toBe(55);

        // 6. Verify Persistence
        // Clone remote repo to a new dir and check file existence
        const verifyDir = await createTempDir('tgp-verify-');
        const { execSync } = await import('node:child_process');
        execSync(`git clone ${remoteRepo} .`, { cwd: verifyDir, stdio: 'ignore' });
        
        const exists = await fs.access(path.join(verifyDir, fibPath)).then(() => true).catch(() => false);
        expect(exists).toBe(true);

        await cleanupDir(verifyDir);
      });

      it('Scenario 2: Concurrency (The Merge Test)', async () => {
        // Agent A
        const dirA = await createTempDir('tgp-agent-a-');
        const configA = await createTgpConfig(dirA, remoteRepo);
        const kernelA = new TGP({ configFile: configA });
        await kernelA.boot();

        // Agent B
        const dirB = await createTempDir('tgp-agent-b-');
        const configB = await createTgpConfig(dirB, remoteRepo);
        const kernelB = new TGP({ configFile: configB });
        await kernelB.boot();

        const toolsA = tgpTools(kernelA);
        const toolsB = tgpTools(kernelB);

        // Both agents create different tools simultaneously
        // This forces one to fail the push, auto-rebase, and push again.
        await Promise.all([
          toolsA.write_file.execute({ 
            path: 'tools/tool_A.ts', 
            content: 'export default () => "A"' 
          }),
          toolsB.write_file.execute({ 
            path: 'tools/tool_B.ts', 
            content: 'export default () => "B"' 
          })
        ]);
        
        // Verify using a fresh Agent C
        const dirC = await createTempDir('tgp-agent-c-');
        const configC = await createTgpConfig(dirC, remoteRepo);
        const kernelC = new TGP({ configFile: configC });
        await kernelC.boot();
        
        const files = await kernelC.vfs.listFiles('tools');
        expect(files).toContain('tools/tool_A.ts');
        expect(files).toContain('tools/tool_B.ts');

        await cleanupDir(dirA);
        await cleanupDir(dirB);
        await cleanupDir(dirC);
      });

      it('Scenario 3: Refactor (Search & Replace)', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        const toolName = 'tools/greet.ts';
        await tools.write_file.execute({ 
          path: toolName, 
          content: `export default function(args: { name: string }) { return "hello " + args.name; }`
        });

        let res = await tools.exec_tool.execute({ path: toolName, args: { name: 'world' } });
        expect(res.result).toBe('hello world');

        await tools.patch_file.execute({
          path: toolName,
          search: 'return "hello " + args.name;',
          replace: 'return "greetings " + args.name;'
        });

        res = await tools.exec_tool.execute({ path: toolName, args: { name: 'world' } });
        expect(res.result).toBe('greetings world');
      });

      it('Scenario 4: Resilience (Infinite Loop)', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        const badTool = 'tools/freeze.ts';
        await tools.write_file.execute({
          path: badTool,
          content: `export default function() { while(true) {} }`
        });

        const res = await tools.exec_tool.execute({ path: badTool, args: {} });
        expect(res.success).toBe(false);
        expect(res.error).toMatch(/timed out/i);
      });

      it('Scenario 5: Security (Jailbreak)', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        const hackTool = 'tools/hack.ts';
        await tools.write_file.execute({
          path: hackTool,
          content: `
            export default async function() {
               return await tgp.read_file('../../package.json');
            }
          `
        });

        const res = await tools.exec_tool.execute({ path: hackTool, args: {} });
        expect(res.success).toBe(false);
        expect(res.error).toMatch(/Security Violation/i);
      });

      it('Scenario 6: SQL Error Propagation', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);

        // Mock DB executor
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const mockExecutor = async (sql: string, _params: any[] = []) => {
          if (sql.includes('fail')) {
            throw new Error('Database Error');
          }
          return [];
        };

        const kernel = new TGP({ 
          configFile: configPath,
          sandboxAPI: { exec_sql: mockExecutor }
        });
        await kernel.boot();

        const tools = { ...tgpTools(kernel), ...createSqlTools(mockExecutor) };

        const dbTool = 'tools/db_ops.ts';
        await tools.write_file.execute({
          path: dbTool,
          content: `
            export default async function(args: { crash: boolean }) {
               if (args.crash) {
                  await tgp.exec_sql('SELECT * FROM users WHERE name = "fail"', []);
               }
            }
          `
        });

        const res = await tools.exec_tool.execute({ path: dbTool, args: { crash: true } });
        expect(res.success).toBe(false);
        expect(res.error).toContain('Database Error');
      });

      it('Scenario 9: Tool Composition (Orchestrator)', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        // 1. Create the Library Tool (The Dependency)
        const libPath = 'tools/lib/multiplier.ts';
        await tools.write_file.execute({
          path: libPath,
          content: `
            export default function multiply(a: number, b: number) {
              return a * b;
            }
          `
        });

        // 2. Create the Consumer Tool (The Orchestrator)
        const consumerPath = 'tools/calc.ts';
        // Note: We use require() because the sandbox environment uses CommonJS shim for inter-tool dependencies.
        await tools.write_file.execute({
          path: consumerPath,
          content: `
            const multiplier = require('./lib/multiplier').default;

            export default function calculate(args: { a: number, b: number }) {
              // Logic: (a * b) + 100
              const product = multiplier(args.a, args.b);
              return product + 100;
            }
          `
        });

        // 3. Execute
        const res = await tools.exec_tool.execute({ 
          path: consumerPath, 
          args: { a: 5, b: 5 } 
        });

        expect(res.success).toBe(true);
        expect(res.result).toBe(125); // (5 * 5) + 100
      });

      it('Scenario 10: Registry Integrity (Meta.json)', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        const docTool = 'tools/docs/roi.ts';
        const description = 'Calculates the Return on Investment based on cost and revenue.';
        
        // Write tool with JSDoc
        await tools.write_file.execute({
          path: docTool,
          content: `
            /**
             * ${description}
             */
            export default function roi(args: { cost: number, revenue: number }) {
              return (args.revenue - args.cost) / args.cost;
            }
          `
        });

        // Verify meta.json in the VFS backing store (on disk)
        // Note: The VFS root is at .tgp inside the tempDir
        const metaPath = path.join(tempDir, '.tgp/meta.json');
        const metaContent = await fs.readFile(metaPath, 'utf-8');
        const meta = JSON.parse(metaContent);

        expect(meta.tools[docTool]).toBeDefined();
        expect(meta.tools[docTool].description).toBe(description);
      });

      it('Scenario 11: Standards Enforcement (Linter)', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        // Test 1: Magic Number
        const magicTool = 'tools/bad/magic.ts';
        await tools.write_file.execute({
          path: magicTool,
          content: `export default function(args: { x: number }) { return args.x * 9999; }`
        });

        let check = await tools.check_tool.execute({ path: magicTool });
        expect(check.valid).toBe(false);
        expect(check.errors.some(e => e.includes('Magic Number'))).toBe(true);

        // Test 2: Hardcoded Secret
        const secretTool = 'tools/bad/secret.ts';
        await tools.write_file.execute({
          path: secretTool,
          content: `
            export default function() { 
              const apiKey = "sk-live-1234567890abcdef12345678"; 
              return apiKey;
            }
          `
        });

        check = await tools.check_tool.execute({ path: secretTool });
        expect(check.valid).toBe(false);
        expect(check.errors.some(e => e.includes('Secret'))).toBe(true);

        // Test 3: Valid Tool (Control)
        const validTool = 'tools/good/clean.ts';
        await tools.write_file.execute({
          path: validTool,
          content: `export default function(args: { factor: number }) { return args.factor * 100; }` // 100 is allowed
        });

        check = await tools.check_tool.execute({ path: validTool });
        expect(check.valid).toBe(true);
      });

      // Note: Scenario 7 (SIGTERM) is skipped as the CLI currently does not have a long-running 'serve' mode to test against.

      it('Scenario 8: CLI Bootstrap', async () => {
        // We assume the project has been built via 'npm run build' for bin/tgp.js to work
        // If not, this test might fail if dist/ doesn't exist.
        const { code } = await runTgpCli(['init'], tempDir);
        expect(code).toBe(0);
        
        const configExists = await fs.access(path.join(tempDir, 'tgp.config.ts')).then(() => true).catch(() => false);
        expect(configExists).toBe(true);
        
        const metaExists = await fs.access(path.join(tempDir, '.tgp/meta.json')).then(() => true).catch(() => false);
        expect(metaExists).toBe(true);
      });
    });
approved: true
linesAdded: 7
linesRemoved: 6
linesDifference: 13
gitCommittedAt: '2025-11-28T07:54:37.304Z'
status: committed
id: 61

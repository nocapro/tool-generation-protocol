uuid: c88df887-f709-40b5-9b2f-93d46a81b2a9
projectId: tool-generation-protocol
createdAt: '2025-11-27T21:00:52.620Z'
gitCommitMsg: 'refactor(sandbox): remove implicit db transaction wrapping for tool execution'
promptSummary: Remove DB transaction wrapping from tool execution; let Agent run raw queries.
reasoning:
  - >-
    I will refactor the sandbox execution flow to remove the mandatory database
    transaction wrapper. The Agent will now rely on direct SQL queries execution
    via the host's bridge, simplifying the runtime and adhering to the "raw SQL"
    requirement.
  - '### Step 1: Remove Transaction Wrapper in Sandbox Execution'
  - >-
    I will rewrite `src/sandbox/execute.ts` to remove `kernel.db.transaction`
    and correct the `createSandboxBridge` call.
  - '### Step 2: Update Bridge Comments'
  - >-
    Updating the comment in `src/sandbox/bridge.ts` to reflect that the DB
    operations are no longer implicitly transactional from the sandbox's
    perspective.
operations:
  - type: write
    path: src/sandbox/execute.ts
    content: >-
      /* eslint-disable no-console */

      import { Kernel } from '../kernel/core.js';

      import { createSandbox } from './isolate.js';

      import { createSandboxBridge } from './bridge.js';

      import { transformSync } from 'esbuild';

      import * as path from 'path';


      /**
       * Executes a tool script within a secure sandbox.
       * 
       * @param kernel The TGP Kernel instance
       * @param code The TypeScript source code of the tool
       * @param args The arguments object to pass to the tool (as 'args' global)
       * @param filePath Optional path of the tool being executed (used for relative imports)
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any

      export async function executeTool(kernel: Kernel, code: string, args:
      Record<string, any> = {}, filePath: string = 'root.ts'): Promise<any> {
        const sandbox = createSandbox({
          memoryLimitMb: 128,
          timeoutMs: 5000 // 5s hard limit
        });

        try {
          // 1. Setup Bridge
          // We pass the kernel directly. The bridge uses kernel.db for queries.
          // We no longer wrap in a transaction (agent manages logic, host runs raw query).
          const bridge = createSandboxBridge(kernel);

          // 2. Module Orchestration (The 'require' Bridge)
          // This host function is called synchronously from the Guest.
          const __tgp_load_module = (baseDir: string, importId: string) => {
            // Security: Ensure we don't traverse out of sandbox (handled by VFS)
            // Resolution Logic:
            // - Starts with '.': Relative to baseDir
            // - Otherwise: Absolute from root (or relative to root)
            
            let targetPath = '';
            if (importId.startsWith('.')) {
              targetPath = path.join(baseDir, importId);
            } else {
              targetPath = importId;
            }

            // Normalize extension (assume .ts if missing)
            if (!targetPath.endsWith('.ts') && !targetPath.endsWith('.js')) {
                // Check if it exists with .ts
                // We can't easily check existence sync in VFS without try/catch read
                // Let's assume .ts for TGP tools
                targetPath += '.ts';
            }

            try {
              const raw = kernel.vfs.readSync(targetPath);
              const transformed = transformSync(raw, {
                loader: 'ts',
                format: 'cjs',
                target: 'es2020',
              });
              
              return {
                code: transformed.code,
                path: targetPath,
                dirname: path.dirname(targetPath)
              };
            } catch (err: any) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              throw new Error(`Failed to load module '${importId}' from '${baseDir}': ${err.message}`);
            }
          };

          // 3. Shim Injection
          // We prepend a CommonJS loader shim to the user code.
          // This allows 'require' to work by calling back to __tgp_load_module.
          const shim = `
            const __moduleCache = {};

            function __makeRequire(baseDir) {
              return function(id) {
                // Check Cache (Global)
                // In a real system, cache keys should be absolute paths.
                // Here we rely on the host to return consistent paths if we wanted perfect caching.
                // For now, we skip cache or use simple ID (flawed for relatives).
                // Let's implement correct caching by asking Host for absolute path first?
                // Simpler: Just reload for now (Stateless).
                
                // Call Host Sync
                const mod = __tgp_load_module.applySync(undefined, [baseDir, id]);
                
                if (__moduleCache[mod.path]) return __moduleCache[mod.path];

                // Wrap in CommonJS Function
                const fun = new Function('exports', 'require', 'module', '__filename', '__dirname', mod.code);
                const newModule = { exports: {} };
                
                // Execute
                fun(newModule.exports, __makeRequire(mod.dirname), newModule, mod.path, mod.dirname);
                
                __moduleCache[mod.path] = newModule.exports;
                return newModule.exports;
              };
            }
            
            // Setup Global Require for the entry point
            // We assume the entry point is at 'filePath'
            global.require = __makeRequire('${path.dirname(filePath)}');
          `;

          const context = {
            ...bridge, // { tgp: { ... } }
            args,
            __tgp_load_module // Injected as Reference
          };

          // Combine Shim + User Code
          // We wrap user code to provide top-level CommonJS variables if needed, 
          // but standard TGP tools are just scripts. 
          // We append the code. The 'shim' sets up 'global.require'.
          const fullScript = shim + '\n' + code;

          const result = await sandbox.compileAndRun(fullScript, context);
          return result;

        } catch (error) {
          console.error(`[TGP] Tool Execution Failed:`, error);
          throw new Error(`Tool execution failed: ${error instanceof Error ? error.message : String(error)}`);
        } finally {
          sandbox.dispose();
        }
      }
    patchStrategy: replace
  - type: write
    path: src/sandbox/bridge.ts
    content: |
      <<<<<<< SEARCH
            // --- Database (Transactional) ---
      =======
            // --- Database ---
      >>>>>>> REPLACE
    patchStrategy: search-replace
snapshot:
  src/sandbox/execute.ts: >-
    /* eslint-disable no-console */

    import { Kernel } from '../kernel/core.js';

    import { createSandbox } from './isolate.js';

    import { createSandboxBridge } from './bridge.js';

    import { transformSync } from 'esbuild';

    import * as path from 'path';


    /**
     * Executes a tool script within a secure sandbox.
     * 
     * @param kernel The TGP Kernel instance
     * @param code The TypeScript source code of the tool
     * @param args The arguments object to pass to the tool (as 'args' global)
     * @param filePath Optional path of the tool being executed (used for relative imports)
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any

    export async function executeTool(kernel: Kernel, code: string, args:
    Record<string, any> = {}, filePath: string = 'root.ts'): Promise<any> {
      const sandbox = createSandbox({
        memoryLimitMb: 128,
        timeoutMs: 5000 // 5s hard limit
      });

      try {
        // 1. Transactional Safety
        // All tool execution happens within a DB transaction.
        return await kernel.db.transaction(async (trx) => {
          const bridge = createSandboxBridge(kernel, trx);

          // 2. Module Orchestration (The 'require' Bridge)
          // This host function is called synchronously from the Guest.
          const __tgp_load_module = (baseDir: string, importId: string) => {
            // Security: Ensure we don't traverse out of sandbox (handled by VFS)
            // Resolution Logic:
            // - Starts with '.': Relative to baseDir
            // - Otherwise: Absolute from root (or relative to root)
            
            let targetPath = '';
            if (importId.startsWith('.')) {
              targetPath = path.join(baseDir, importId);
            } else {
              targetPath = importId;
            }

            // Normalize extension (assume .ts if missing)
            if (!targetPath.endsWith('.ts') && !targetPath.endsWith('.js')) {
               // Check if it exists with .ts
               // We can't easily check existence sync in VFS without try/catch read
               // Let's assume .ts for TGP tools
               targetPath += '.ts';
            }

            try {
              const raw = kernel.vfs.readSync(targetPath);
              const transformed = transformSync(raw, {
                loader: 'ts',
                format: 'cjs',
                target: 'es2020',
              });
              
              return {
                code: transformed.code,
                path: targetPath,
                dirname: path.dirname(targetPath)
              };
            } catch (err: any) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              throw new Error(`Failed to load module '${importId}' from '${baseDir}': ${err.message}`);
            }
          };

          // 3. Shim Injection
          // We prepend a CommonJS loader shim to the user code.
          // This allows 'require' to work by calling back to __tgp_load_module.
          const shim = `
            const __moduleCache = {};

            function __makeRequire(baseDir) {
              return function(id) {
                // Check Cache (Global)
                // In a real system, cache keys should be absolute paths.
                // Here we rely on the host to return consistent paths if we wanted perfect caching.
                // For now, we skip cache or use simple ID (flawed for relatives).
                // Let's implement correct caching by asking Host for absolute path first?
                // Simpler: Just reload for now (Stateless).
                
                // Call Host Sync
                const mod = __tgp_load_module.applySync(undefined, [baseDir, id]);
                
                if (__moduleCache[mod.path]) return __moduleCache[mod.path];

                // Wrap in CommonJS Function
                const fun = new Function('exports', 'require', 'module', '__filename', '__dirname', mod.code);
                const newModule = { exports: {} };
                
                // Execute
                fun(newModule.exports, __makeRequire(mod.dirname), newModule, mod.path, mod.dirname);
                
                __moduleCache[mod.path] = newModule.exports;
                return newModule.exports;
              };
            }
            
            // Setup Global Require for the entry point
            // We assume the entry point is at 'filePath'
            global.require = __makeRequire('${path.dirname(filePath)}');
          `;

          const context = {
            ...bridge, // { tgp: { ... } }
            args,
            __tgp_load_module // Injected as Reference
          };

          // Combine Shim + User Code
          // We wrap user code to provide top-level CommonJS variables if needed, 
          // but standard TGP tools are just scripts. 
          // We append the code. The 'shim' sets up 'global.require'.
          const fullScript = shim + '\n' + code;

          const result = await sandbox.compileAndRun(fullScript, context);
          return result;
        });

      } catch (error) {
        console.error(`[TGP] Tool Execution Failed:`, error);
        throw new Error(`Tool execution failed: ${error instanceof Error ? error.message : String(error)}`);
      } finally {
        sandbox.dispose();
      }
    }
  src/sandbox/bridge.ts: >-
    /* eslint-disable no-console */

    import { Kernel } from '../kernel/core.js';

    import * as path from 'path';


    /**
     * Creates the Bridge Object exposed to the Sandbox.
     * This maps secure Kernel methods to the Guest environment.
     * 
     * We expose a structured 'tgp' object to the guest.
     */
    export function createSandboxBridge({ vfs, db, config }: Pick<Kernel, 'vfs'
    | 'db' | 'config'>) {
      const { allowedDirs } = config.fs;

      const isAllowedWrite = (target: string): boolean => {
        // Normalize target to ensure clean comparison (remove leading ./, etc)
        const normalizedTarget = path.normalize(target).replace(/^(\.\/)/, '');
        
        return allowedDirs.some(dir => {
          const normalizedDir = path.normalize(dir).replace(/^(\.\/)/, '');
          // Check if target is inside the allowed dir
          return normalizedTarget.startsWith(normalizedDir);
        });
      };

      return {
        tgp: {
          // --- Filesystem Bridge (Jailed) ---
          read_file: async (path: string) => {
            return vfs.readFile(path);
          },

          write_file: async (path: string, content: string) => {
            if (!isAllowedWrite(path)) {
              throw new Error(`Security Violation: Write access denied for '${path}'. Allowed directories: ${allowedDirs.join(', ')}`);
            }
            return vfs.writeFile(path, content);
          },

          list_files: async (dir: string) => {
            return vfs.listFiles(dir, false);
          },

          // --- Network Bridge (Allowed Only) ---
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          fetch: async (url: string, init?: any) => {
            // Security: Parse URL and allow-list check could happen here
            const response = await fetch(url, init);
            const text = await response.text();
            return {
              status: response.status,
              text: () => text,
              json: () => JSON.parse(text),
            };
          },

          // --- Logger ---
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          log: (...args: any[]) => {
            console.log('[TGP-TOOL]', ...args);
          },

          // --- Database (Transactional) ---
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          db_query: async (sql: string, params: any[] = []) => {
            return db.query(sql, params);
          }
        }
      };
    }
approved: true
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: committed
id: 26

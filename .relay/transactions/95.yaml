uuid: f8ea0d75-ca5f-4f0c-bc03-30b953b57207
projectId: tool-generation-protocol
createdAt: '2025-11-29T11:43:45.754Z'
gitCommitMsg: >-
  feat: add governance and self-healing verification

  - Upgrade local git backend to support PR strategy (feature branches) - Update
  test utilities to support writeStrategy configuration - Add Gatekeeper Mode
  and Self-Healing loop scenarios
promptSummary: Implement and verify Governance (PR mode) and Self-Healing E2E scenarios.
reasoning:
  - >-
    To enable verification of the "Governance" and "Self-Healing" capabilities
    promised in the README, I will upgrade the local Git backend to support the
    Pull Request strategy (by creating feature branches) and add two new E2E
    scenarios. I will also update the test utilities (including the Docker
    injection version) to support configuring the write strategy.
  - >-
    1.  **Modify `src/kernel/git.ts`**: Update `createLocalGitBackend` to check
    `writeStrategy`. If 'pr', create a feature branch before committing.
  - >-
    2.  **Modify `test/e2e/utils.ts`**: Update `createTgpConfig` to accept an
    options object for `writeStrategy`.
  - >-
    3.  **Modify `test/e2e/scenarios.test.ts`**: Add `Scenario 12` (Gatekeeper
    Mode) and `Scenario 13` (Self-Healing).
  - >-
    4.  **Modify `test/docker/npm-compat.test.ts`**: Update the injected utility
    script to match the new `createTgpConfig` signature, preventing Docker test
    failures.
operations:
  - type: write
    path: src/kernel/git.ts
    content: >
      --- src/kernel/git.ts

      +++ src/kernel/git.ts

      @@ -95,7 +95,7 @@
       
       function createLocalGitBackend(config: TGPConfig, logger: Logger): GitBackend {
         const dir = config.rootDir;
      -  const { repo, branch } = config.git;

      +  const { repo, branch, writeStrategy } = config.git;
       
         return {
           async hydrate() {
      @@ -122,23 +122,50 @@
           async persist(message: string, files: string[]) {
             if (files.length === 0) return;
             logger.info(`[Local] Persisting ${files.length} files...`);
      +

      +      let pushTarget = branch;

      +

      +      // Handle PR Strategy: Branch switching

      +      if (writeStrategy === 'pr') {

      +          const timestamp = new Date().toISOString().replace(/[:.]/g,
      '-');

      +          const safeMsg = message.replace(/[^a-zA-Z0-9-]/g, '-').slice(0,
      30);

      +          const featureBranch = `tgp/feat-${timestamp}-${safeMsg}`;

      +          

      +          logger.info(`[Local] Strategy 'pr': Switching to
      ${featureBranch}`);

      +          

      +          try {

      +             await execGit(['checkout', '-b', featureBranch], dir,
      logger);

      +             pushTarget = featureBranch;

      +          } catch (e) {

      +             logger.warn(`[Local] Failed to create branch
      ${featureBranch}`, e);

      +             throw new Error(`Failed to create feature branch: ${e}`);

      +          }

      +      }
             
             for (const f of files) {
               await execGit(['add', f], dir, logger);
             }
             
             try {
               await execGit(['commit', '-m', message], dir, logger);
             } catch(e) {
                // Commit might fail if no changes
                logger.warn(`[Local] Commit failed (empty?):`, String(e));
                return;
             }
       
             try {
      -          await execGit(['push', 'origin', branch], dir, logger);

      -      } catch {

      -          // Handle non-fast-forward by pulling first (simple auto-merge)

      -          logger.warn(`[Local] Push failed. Attempting merge...`);

      -          // We use standard merge (no-rebase) as it handles 'meta.json'
      append conflicts slightly better 

      -          // in automated scenarios than rebase, which can get stuck.

      -          await execGit(['pull', '--no-rebase', 'origin', branch], dir,
      logger);

      -          await execGit(['push', 'origin', branch], dir, logger);

      +          await execGit(['push', 'origin', pushTarget], dir, logger);

      +

      +          if (writeStrategy === 'pr') {

      +             logger.info(`[Local] Pushed feature branch ${pushTarget}.
      (Simulated PR)`);

      +          }

      +      } catch (e) {

      +          if (writeStrategy === 'direct') {

      +             // Handle non-fast-forward by pulling first (simple
      auto-merge)

      +             logger.warn(`[Local] Push failed. Attempting merge...`);

      +             // We use standard merge (no-rebase) as it handles
      'meta.json' append conflicts slightly better 

      +             // in automated scenarios than rebase, which can get stuck.

      +             await execGit(['pull', '--no-rebase', 'origin', branch],
      dir, logger);

      +             await execGit(['push', 'origin', branch], dir, logger);

      +          } else {

      +             throw e;

      +          }
             }
           }
         };
    patchStrategy: standard-diff
  - type: write
    path: test/e2e/utils.ts
    content: >
      --- test/e2e/utils.ts

      +++ test/e2e/utils.ts

      @@ -74,7 +74,13 @@
        * Generates a tgp.config.ts file in the test directory pointing to the local bare repo.
        * We use an absolute path for rootDir to ensure tests don't pollute the project root.
        */
      -export async function createTgpConfig(workDir: string, remoteRepo:
      string, fileName: string = 'tgp.config.js'): Promise<string> {

      +export async function createTgpConfig(

      +  workDir: string, 

      +  remoteRepo: string, 

      +  options: { fileName?: string, writeStrategy?: 'direct' | 'pr' } = {}

      +): Promise<string> {

      +    const fileName = options.fileName ?? 'tgp.config.js';

      +    const writeStrategy = options.writeStrategy ?? 'direct';
           const rootDir = path.join(workDir, '.tgp').split(path.sep).join('/');
           const remotePath = remoteRepo.split(path.sep).join('/');
           const allowedDir = workDir.split(path.sep).join('/');
      @@ -103,7 +109,8 @@
           provider: 'local',
           repo: '${remotePath}',
           branch: 'main',
      -    auth: { token: 'mock', user: 'test', email: 'test@example.com' }

      +    auth: { token: 'mock', user: 'test', email: 'test@example.com' },

      +    writeStrategy: '${writeStrategy}'
         },
         fs: {
           allowedDirs: ['${allowedDir}', '${os.tmpdir().split(path.sep).join('/')}'],
    patchStrategy: standard-diff
  - type: write
    path: test/e2e/scenarios.test.ts
    content: >
      --- test/e2e/scenarios.test.ts

      +++ test/e2e/scenarios.test.ts

      @@ -293,5 +293,53 @@
           expect(metaExists).toBe(true);
         });
      +

      +  it('Scenario 12: Governance (Gatekeeper Mode)', async () => {

      +    // Verify that PR strategy creates a separate branch

      +    const configPath = await createTgpConfig(tempDir, remoteRepo, {
      writeStrategy: 'pr' });

      +    const kernel = new TGP({ configFile: configPath });

      +    await kernel.boot();

      +    const tools = tgpTools(kernel);

      +

      +    const featTool = 'tools/feature.ts';

      +    await tools.write_file.execute({

      +      path: featTool,

      +      content: 'export default "feature"'

      +    });

      +

      +    // Assert: Local repo should be on a feature branch

      +    const { execSync } = await import('node:child_process');

      +    const tgpRoot = path.join(tempDir, '.tgp');

      +    const currentBranch = execSync('git branch --show-current', { cwd:
      tgpRoot }).toString().trim();

      +    

      +    expect(currentBranch).toMatch(/^tgp\/feat-/);

      +    

      +    // Assert: Remote 'main' should NOT have the file yet

      +    const verifyDir = await createTempDir('tgp-verify-gov-');

      +    execSync(`git clone ${remoteRepo} .`, { cwd: verifyDir, stdio:
      'ignore' });

      +    

      +    const existsInMain = await fs.access(path.join(verifyDir,
      featTool)).then(() => true).catch(() => false);

      +    expect(existsInMain).toBe(false);

      +    

      +    await cleanupDir(verifyDir);

      +  });

      +

      +  it('Scenario 13: Self-Healing (The Fix Loop)', async () => {

      +    const configPath = await createTgpConfig(tempDir, remoteRepo);

      +    const kernel = new TGP({ configFile: configPath });

      +    await kernel.boot();

      +    const tools = tgpTools(kernel);

      +

      +    const brokenTool = 'tools/broken.ts';

      +    // 1. Write Broken Code

      +    await tools.write_file.execute({ path: brokenTool, content: 'const x
      = ;' });

      +    

      +    // 2. Diagnose

      +    const diag = await tools.check_tool.execute({ path: brokenTool });

      +    expect(diag.valid).toBe(false);

      +    

      +    // 3. Patch

      +    await tools.apply_diff.execute({

      +      path: brokenTool,

      +      diff: `<<<<<<< SEARCH\nconst x = ;\n=======\nconst x = 10;\nexport
      default x;\n>>>>>>> REPLACE`

      +    });

      +    

      +    // 4. Verify & Execute

      +    const check = await tools.check_tool.execute({ path: brokenTool });

      +    expect(check.valid).toBe(true);

      +    

      +    const res = await tools.exec_tool.execute({ path: brokenTool, args:
      {} });

      +    expect(res.success).toBe(true);

      +    expect(res.result).toBe(10);

      +  });
       });
    patchStrategy: standard-diff
  - type: write
    path: test/docker/npm-compat.test.ts
    content: >
      <<<<<<< SEARCH

      export async function createTgpConfig(workDir: string, remoteRepo: string,
      fileName: string = 'tgp.config.ts'): Promise<string> {
          const rootDir = path.join(workDir, '.tgp').split(path.sep).join('/');
          const remotePath = remoteRepo.split(path.sep).join('/');
          const allowedDir = workDir.split(path.sep).join('/');

          // OVERRIDE: Use the package name directly for imports
          const configContent = \`
      import { defineTGPConfig } from 'tool-generation-protocol';


      export default defineTGPConfig({
        rootDir: '\${rootDir}',
        git: {
          provider: 'local',
          repo: '\${remotePath}',
          branch: 'main',
          auth: { token: 'mock', user: 'test', email: 'test@example.com' }
        },
      =======

      export async function createTgpConfig(
          workDir: string, 
          remoteRepo: string, 
          options: { fileName?: string, writeStrategy?: 'direct' | 'pr' } = {}
      ): Promise<string> {
          const fileName = options.fileName ?? 'tgp.config.ts';
          const writeStrategy = options.writeStrategy ?? 'direct';

          const rootDir = path.join(workDir, '.tgp').split(path.sep).join('/');
          const remotePath = remoteRepo.split(path.sep).join('/');
          const allowedDir = workDir.split(path.sep).join('/');

          // OVERRIDE: Use the package name directly for imports
          const configContent = \`
      import { defineTGPConfig } from 'tool-generation-protocol';


      export default defineTGPConfig({
        rootDir: '\${rootDir}',
        git: {
          provider: 'local',
          repo: '\${remotePath}',
          branch: 'main',
          auth: { token: 'mock', user: 'test', email: 'test@example.com' },
          writeStrategy: '\${writeStrategy}'
        },
      >>>>>>> REPLACE
    patchStrategy: search-replace
snapshot:
  test/e2e/utils.ts: >-
    import * as fs from 'node:fs/promises';

    import * as path from 'node:path';

    import * as os from 'node:os';

    import { spawn, execSync } from 'node:child_process';

    import { fileURLToPath } from 'node:url';


    // ESM Polyfills

    const __filename = fileURLToPath(import.meta.url);

    const __dirname = path.dirname(__filename);


    // Robust Project Root Detection

    // If running from dist/test/e2e, we are 3 levels deep from root
    (dist/test/e2e -> dist/test -> dist -> root)

    // If running from test/e2e, we are 2 levels deep (test/e2e -> test -> root)

    const isRunningInDist = __dirname.includes(path.join('dist', 'test',
    'e2e'));


    const projectRoot = isRunningInDist 
      ? path.resolve(__dirname, '../../../') 
      : path.resolve(__dirname, '../../');

    // Track temp dirs for cleanup

    const tempDirs: string[] = [];


    /**
     * Creates a unique temporary directory for a test case.
     * Registers it for auto-cleanup on process exit.
     */
    export async function createTempDir(prefix: string = 'tgp-e2e-'):
    Promise<string> {
      const tmpDir = os.tmpdir();
      const dir = await fs.mkdtemp(path.join(tmpDir, prefix));
      tempDirs.push(dir);
      return dir;
    }


    /**
     * Recursively deletes a directory.
     */
    export async function cleanupDir(dir: string): Promise<void> {
      await fs.rm(dir, { recursive: true, force: true }).catch(() => {});
    }


    /**
     * Initializes a bare Git repository at the specified path.
     * This serves as the 'Remote' for the E2E tests.
     */
    export async function initBareRepo(dir: string): Promise<void> {
      await fs.mkdir(dir, { recursive: true });
      execSync(`git init --bare`, { cwd: dir, stdio: 'ignore' });
      
      // Setup: Create an initial commit so all clones share a history.
      // This prevents "fatal: refusing to merge unrelated histories" during concurrent pushes.
      const initDir = await createTempDir('tgp-init-');
      execSync(`git init`, { cwd: initDir, stdio: 'ignore' });
      await fs.writeFile(path.join(initDir, 'README.md'), '# Remote Root');
      execSync(`git add .`, { cwd: initDir, stdio: 'ignore' });
      execSync(`git commit -m "Initial commit"`, { cwd: initDir, stdio: 'ignore' });
      execSync(`git remote add origin ${dir}`, { cwd: initDir, stdio: 'ignore' });
      execSync(`git push origin master:main`, { cwd: initDir, stdio: 'ignore' }); // push master to main
      await cleanupDir(initDir);

      execSync(`git symbolic-ref HEAD refs/heads/main`, { cwd: dir, stdio: 'ignore' });
    }


    /**
     * Generates a tgp.config.ts file in the test directory pointing to the local bare repo.
     * We use an absolute path for rootDir to ensure tests don't pollute the project root.
     */
    export async function createTgpConfig(workDir: string, remoteRepo: string,
    fileName: string = 'tgp.config.js'): Promise<string> {
        const rootDir = path.join(workDir, '.tgp').split(path.sep).join('/');
        const remotePath = remoteRepo.split(path.sep).join('/');
        const allowedDir = workDir.split(path.sep).join('/');

        // Resolve import source: prefer dist (prod behavior), fallback to source (test/dev behavior)
        const distConfigPath = path.join(projectRoot, 'dist/src/config.js');
        let importSource = distConfigPath;

        try {
          await fs.access(distConfigPath);
        } catch {
          // Dist missing, fallback to source
          importSource = path.join(projectRoot, 'src/config.ts');
        }
        
        // Normalize path for string interpolation
        importSource = importSource.split(path.sep).join('/');

        const configContent = `
    import { defineTGPConfig } from '${importSource}';


    export default defineTGPConfig({
      rootDir: '${rootDir}',
      git: {
        provider: 'local',
        repo: '${remotePath}',
        branch: 'main',
        auth: { token: 'mock', user: 'test', email: 'test@example.com' }
      },
      fs: {
        allowedDirs: ['${allowedDir}', '${os.tmpdir().split(path.sep).join('/')}'],
        blockUpwardTraversal: false
      },
      allowedImports: ['zod', 'date-fns']
    });

    `;
        const configPath = path.join(workDir, fileName);
        await fs.writeFile(configPath, configContent);
        return configPath;
    }


    /**
     * Executes the TGP CLI binary in the given directory.
     */
    export function runTgpCli(args: string[], cwd: string): Promise<{ stdout:
    string, stderr: string, code: number }> {
        return new Promise(async (resolve) => {
            const distCli = path.join(projectRoot, 'dist/cli.js');
            let cmd = 'node';
            let script = path.join(projectRoot, 'bin/tgp.js');

            try {
               await fs.access(distCli);
            } catch {
               // Fallback to running source via Bun if build is missing
               cmd = 'bun';
               script = path.join(projectRoot, 'src/cli/index.ts');
            }

            const proc = spawn(cmd, [script, ...args], {
                cwd,
                env: { ...process.env, NODE_ENV: 'test' }
            });

            let stdout = '';
            let stderr = '';

            proc.stdout.on('data', d => stdout += d.toString());
            proc.stderr.on('data', d => stderr += d.toString());

            proc.on('close', (code) => {
                resolve({ stdout, stderr, code: code ?? -1 });
            });
        });
    }


    // Cleanup hook

    process.on('exit', () => {
        tempDirs.forEach(d => {
            try { execSync(`rm -rf ${d}`); } catch {}
        });
    });
  src/kernel/git.ts: >2
     
    import * as git from 'isomorphic-git';

    import { TGPConfig, Logger } from '../types.js';

    import * as path from 'path';

    import { spawn } from 'child_process';


    /**
     * The Git Interface required by the Kernel.
     * We rely on the 'fs' interface compatible with isomorphic-git.
     */
    export interface GitBackend {
      hydrate(): Promise<void>;
      persist(message: string, files: string[]): Promise<void>;
    }


    export interface GitDependencies {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      fs: any;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      http: any;
    }


    /**
     * Strategy interface for persisting changes to the upstream repository.
     */
    interface GitWriteStrategy {
      persist(message: string, files: string[]): Promise<void>;
    }


    /**
     * Adapter interface for Git Hosting Platforms.
     * Handles platform-specific API calls like creating Pull Requests.
     */
    interface GitPlatformAdapter {
      createPullRequest(opts: {
        title: string;
        branch: string;
        base: string;
        body: string;
      }): Promise<void>;
    }


    class GitHubAdapter implements GitPlatformAdapter {
      constructor(
        private repo: string,
        private token: string,
        private apiBaseUrl: string,
        private logger: Logger
      ) {}

      async createPullRequest(opts: { title: string; branch: string; base: string; body: string }): Promise<void> {
        const [owner, repoName] = this.repo.split('/');
        const url = new URL(`/repos/${owner}/${repoName}/pulls`, this.apiBaseUrl).href;

        this.logger.info(`Creating Pull Request on ${this.repo}...`);

        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: {
              'Authorization': `token ${this.token}`,
              'Accept': 'application/vnd.github.v3+json',
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              title: opts.title,
              head: opts.branch,
              base: opts.base,
              body: opts.body,
            }),
          });

          const result = await response.json();
          if (response.ok) {
            this.logger.info(`Successfully created Pull Request: ${result.html_url}`);
          } else if (response.status === 422) {
            this.logger.warn(`Could not create PR (it may already exist): ${JSON.stringify(result.errors)}`);
          } else {
            this.logger.error(`GitHub API Error: ${response.status} ${response.statusText}`, result);
          }
        } catch (e) {
          this.logger.error('Failed to create pull request via API.', e);
          throw e;
        }
      }
    }


    class NotImplementedAdapter implements GitPlatformAdapter {
      constructor(private provider: string) {}
      async createPullRequest(): Promise<void> {
        throw new Error(`Git Provider '${this.provider}' is not yet implemented.`);
      }
    }


    // --- Local Git Implementation (Shell-based) ---

    // Used for E2E testing and Air-gapped environments

    async function execGit(args: string[], cwd: string, logger: Logger):
    Promise<void> {
      logger.debug(`[Local] Executing: git ${args.join(' ')} in ${cwd}`);
      return new Promise((resolve, reject) => {
        const proc = spawn('git', args, { cwd, stdio: 'pipe' });
        let output = '';
        proc.stdout.on('data', d => output += d.toString());
        proc.stderr.on('data', d => output += d.toString());
        
        proc.on('close', (code) => {
          if (code === 0) resolve();
          else reject(new Error(`Git command failed: git ${args.join(' ')} in ${cwd}\nOutput: ${output}`));
        });
      });
    }


    function createLocalGitBackend(config: TGPConfig, logger: Logger):
    GitBackend {
      const dir = config.rootDir;
      const { repo, branch } = config.git;

      return {
        async hydrate() {
          const fs = await import('node:fs/promises');
          const gitDirExists = await fs.stat(path.join(dir, '.git')).then(() => true).catch(() => false);
          
          if (!gitDirExists) {
            logger.info(`[Local] Cloning ${repo} into ${dir}...`);
            await fs.mkdir(path.dirname(dir), { recursive: true });
            // Clone needs to happen in parent dir
            // We assume 'repo' is an absolute path to a bare repo
            await execGit(['clone', repo, path.basename(dir)], path.dirname(dir), logger);
            
            // Ensure we are on correct branch
            try {
                await execGit(['checkout', branch], dir, logger);
            } catch {
                logger.warn(`[Local] Failed to checkout ${branch}, assuming default.`);
            }
          } else {
            logger.info(`[Local] Pulling latest from ${repo}...`);
            await execGit(['pull', 'origin', branch], dir, logger);
          }
        },

        async persist(message: string, files: string[]) {
          if (files.length === 0) return;
          logger.info(`[Local] Persisting ${files.length} files...`);
          
          for (const f of files) {
            await execGit(['add', f], dir, logger);
          }
          
          try {
            await execGit(['commit', '-m', message], dir, logger);
          } catch(e) {
             // Commit might fail if no changes
             logger.warn(`[Local] Commit failed (empty?):`, String(e));
             return;
          }

          try {
              await execGit(['push', 'origin', branch], dir, logger);
          } catch {
              // Handle non-fast-forward by pulling first (simple auto-merge)
              logger.warn(`[Local] Push failed. Attempting merge...`);
              // We use standard merge (no-rebase) as it handles 'meta.json' append conflicts slightly better 
              // in automated scenarios than rebase, which can get stuck.
              await execGit(['pull', '--no-rebase', 'origin', branch], dir, logger);
              await execGit(['push', 'origin', branch], dir, logger);
          }
        }
      };
    }


    /**
     * Factory to create the Git Backend based on configuration.
     */
    export function createGitBackend(deps: GitDependencies, config: TGPConfig,
    logger: Logger): GitBackend {
      const dir = config.rootDir;
      const { repo, auth, branch, writeStrategy, apiBaseUrl, provider } = config.git;
      const { fs, http } = deps;

      if (provider === 'local') {
        return createLocalGitBackend(config, logger);
      }

      // Configuration for isomorphic-git
      const gitOpts = {
        fs,
        dir,
        http,
        onAuth: () => ({ username: auth.token }),
      };

      const author = {
        name: auth.user,
        email: auth.email,
      };

      // Select Platform Adapter
      let platformAdapter: GitPlatformAdapter;
      if (provider === 'github') {
        platformAdapter = new GitHubAdapter(repo, auth.token, apiBaseUrl, logger);
      } else {
        platformAdapter = new NotImplementedAdapter(provider);
      }

      // --- Strategy Implementations ---

      const directStrategy: GitWriteStrategy = {
        async persist(message: string, filesToAdd: string[]) {
          if (filesToAdd.length === 0) return;

          // 1. Add files
          for (const filepath of filesToAdd) {
            try {
               // check if file exists before adding
               await git.add({ ...gitOpts, filepath });
            } catch (e) {
               logger.warn(`Git Add failed for ${filepath}`, e);
               throw new Error(`Failed to stage file ${filepath}: ${e instanceof Error ? e.message : String(e)}`);
            }
          }

          try {
            // 2. Commit
            const sha = await git.commit({
              ...gitOpts,
              message,
              author,
            });
            logger.info(`Committed ${sha.slice(0, 7)}: ${message}`);

            // 3. Push
            logger.info(`Pushing to ${branch}...`);
            await git.push({
              ...gitOpts,
              remote: 'origin',
              ref: branch,
            });
          } catch (e) {
            logger.error(`Git Commit/Push failed:`, e);
            throw new Error(`Failed to persist changes to Git: ${e instanceof Error ? e.message : String(e)}`);
          }
        }
      };

      const prStrategy: GitWriteStrategy = {
        async persist(message: string, files: string[]) {
          if (files.length === 0) return;
          
          // 1. Get current branch
          const currentBranch = await git.currentBranch({ ...gitOpts }) ?? 'HEAD';
          
          // 2. If we are on the protected branch (main/master), we must fork
          let targetBranch = currentBranch;
          
          if (currentBranch === branch) {
             const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
             // Sanitize message for branch name
             const safeMsg = message.replace(/[^a-zA-Z0-9-]/g, '-').slice(0, 30);
             targetBranch = `tgp/feat-${timestamp}-${safeMsg}`;
             
             logger.info(`Switching to new branch: ${targetBranch}`);
             
             await git.branch({ ...gitOpts, ref: targetBranch });
             await git.checkout({ ...gitOpts, ref: targetBranch });
          } else {
             logger.info(`Already on feature branch: ${targetBranch}`);
          }

          for (const filepath of files) {
            await git.add({ ...gitOpts, filepath }).catch(e => logger.warn(`Git Add failed ${filepath}`, e));
          }

          await git.commit({
            ...gitOpts,
            message: message,
            author,
          });
          
          logger.info(`Changes committed to ${targetBranch}.`);
          
          // Try to push the feature branch if auth is present
          try {
              await git.push({
                ...gitOpts,
                remote: 'origin',
                ref: targetBranch,
              });
              logger.info(`Pushed ${targetBranch} to origin.`);
              await platformAdapter.createPullRequest({
                title: message,
                branch: targetBranch,
                base: branch,
                body: `Forged by TGP.\nCommit Message: ${message}`,
              });
          } catch (e) {
              logger.warn(`Failed to push feature branch. Changes are local only.`, e);
          }
        }
      };

      // Select Strategy
      const strategy = writeStrategy === 'pr' ? prStrategy : directStrategy;

      return {
        async hydrate() {
          try {
            // 1. Check if repo exists locally
            const gitDirExists = (await fs.promises.stat(path.join(dir, '.git'))
              .then(() => true)
              .catch(() => false)) as boolean;

            if (!gitDirExists) {
              // Clone
              logger.info(`Cloning ${repo} into ${dir}...`);
              await git.clone({
                ...gitOpts,
                url: `https://github.com/${repo}.git`,
                ref: branch,
                singleBranch: true,
                depth: 1,
              });
            } else {
              // Pull
              logger.info(`Pulling latest from ${repo}...`);
              await git.pull({
                ...gitOpts,
                remote: 'origin',
                ref: branch,
                singleBranch: true,
                author,
              });
            }
          } catch (error) {
            logger.error(`Git Hydration Failed:`, error);
            // Fail fast: The agent cannot operate without a consistent filesystem state.
            throw error;
          }
        },

        async persist(message: string, filesToAdd: string[]) {
          return strategy.persist(message, filesToAdd);
        }
      };
    }
  test/docker/npm-compat.test.ts: >-
    import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach }
    from 'bun:test';

    import * as path from 'node:path';

    import * as fs from 'node:fs/promises';

    import * as os from 'node:os';

    import { createTarball, Container } from './utils.js';


    // Define the root of the project

    const projectRoot = path.resolve(__dirname, '../../');


    // Modified utils.ts to be injected into the container

    // This ensures tests use the installed package 'tool-generation-protocol' 

    // instead of trying to resolve local paths or dist/ folders.

    const CONTAINER_UTILS_TS = `

    import * as fs from 'node:fs/promises';

    import * as path from 'node:path';

    import * as os from 'node:os';

    import { spawn, execSync } from 'node:child_process';


    const tempDirs: string[] = [];


    // Create workspaces inside /app/test_workspaces to ensure they are within
    the project tree

    // where node_modules are installed (/app/node_modules). This fixes module
    resolution.

    const WORKSPACE_ROOT = '/app/test_workspaces';


    export async function createTempDir(prefix: string = 'tgp-e2e-'):
    Promise<string> {
      await fs.mkdir(WORKSPACE_ROOT, { recursive: true });
      const dir = await fs.mkdtemp(path.join(WORKSPACE_ROOT, prefix));
      tempDirs.push(dir);
      return dir;
    }


    export async function cleanupDir(dir: string): Promise<void> {
      await fs.rm(dir, { recursive: true, force: true }).catch(() => {});
    }


    export async function initBareRepo(dir: string): Promise<void> {
      await fs.mkdir(dir, { recursive: true });
      execSync(\`git init --bare\`, { cwd: dir, stdio: 'ignore' });
      const initDir = await createTempDir('tgp-init-');
      execSync(\`git init\`, { cwd: initDir, stdio: 'ignore' });
      await fs.writeFile(path.join(initDir, 'README.md'), '# Remote Root');
      execSync(\`git add .\`, { cwd: initDir, stdio: 'ignore' });
      execSync(\`git commit -m "Initial commit"\`, { cwd: initDir, stdio: 'ignore' });
      execSync(\`git remote add origin \${dir}\`, { cwd: initDir, stdio: 'ignore' });
      execSync(\`git push origin master:main\`, { cwd: initDir, stdio: 'ignore' });
      await cleanupDir(initDir);
      execSync(\`git symbolic-ref HEAD refs/heads/main\`, { cwd: dir, stdio: 'ignore' });
    }


    export async function createTgpConfig(workDir: string, remoteRepo: string,
    fileName: string = 'tgp.config.ts'): Promise<string> {
        const rootDir = path.join(workDir, '.tgp').split(path.sep).join('/');
        const remotePath = remoteRepo.split(path.sep).join('/');
        const allowedDir = workDir.split(path.sep).join('/');

        // OVERRIDE: Use the package name directly for imports
        const configContent = \`
    import { defineTGPConfig } from 'tool-generation-protocol';


    export default defineTGPConfig({
      rootDir: '\${rootDir}',
      git: {
        provider: 'local',
        repo: '\${remotePath}',
        branch: 'main',
        auth: { token: 'mock', user: 'test', email: 'test@example.com' }
      },
      fs: {
        allowedDirs: ['\${allowedDir}', '\${os.tmpdir().split(path.sep).join('/')}'],
        blockUpwardTraversal: false
      },
      allowedImports: ['zod', 'date-fns']
    });

    \`;
        const configPath = path.join(workDir, fileName);
        await fs.writeFile(configPath, configContent);
        return configPath;
    }


    export function runTgpCli(args: string[], cwd: string): Promise<{ stdout:
    string, stderr: string, code: number }> {
        return new Promise(async (resolve) => {
            // OVERRIDE: Use bunx tgp to execute the installed binary
            // Since we are running inside /app/test_workspaces, this should find local node_modules
            const proc = spawn('bunx', ['tgp', ...args], {
                cwd,
                env: { ...process.env, NODE_ENV: 'test' }
            });

            let stdout = '';
            let stderr = '';

            proc.stdout.on('data', d => stdout += d.toString());
            proc.stderr.on('data', d => stderr += d.toString());

            proc.on('close', (code) => {
                resolve({ stdout, stderr, code: code ?? -1 });
            });
        });
    }


    process.on('exit', () => {
        tempDirs.forEach(d => {
            try { execSync(\`rm -rf \${d}\`); } catch {}
        });
    });

    `;


    describe('Docker: NPM Compatibility', () => {
      let tarballPath: string;
      let container: Container;
      
      // High timeout for Docker operations
      // Increased to 4 minutes to allow for slow npm installs (especially native modules) in CI
      const TIMEOUT = 240000;

      beforeAll(async () => {
        // 1. Build the Tarball from source
        console.log('[Docker] Building NPM Tarball...');
        tarballPath = await createTarball(projectRoot);
        console.log(`[Docker] Tarball created at: ${tarballPath}`);
      });

      beforeEach(async () => {
        // 2. Start a fresh container
        // Use Node to verify true NPM compatibility and allow native modules (isolated-vm) to build/install correctly
        container = new Container('node:22');
        await container.start();
        console.log(`[Docker] Container started: ${container.id}`);
      });

      afterEach(async () => {
        if (container) await container.stop();
      });

      afterAll(async () => {
        // Cleanup the local tarball
        if (tarballPath) await fs.rm(tarballPath, { force: true });
      });

      it('installs and runs E2E scenarios correctly', async () => {
        // Helper for verbose execution to debug installation issues
        const exec = async (cmd: string[], opts: { cwd?: string } = {}) => {
            console.log(`[Docker] Executing: ${cmd.join(' ')}`);
            const res = await container.exec(cmd, opts);
            if (res.stdout) console.log(res.stdout);
            if (res.stderr) console.error(res.stderr);
            if (res.exitCode !== 0) throw new Error(`Command failed with code ${res.exitCode}: ${cmd.join(' ')}`);
            return res;
        };

        // 3. Prepare Environment inside Container
        console.log('[Docker] Installing dependencies...');
        await exec(['apt-get', 'update']);
        // Install git (for tests), curl/unzip (for bun), and build tools (for native modules like isolated-vm)
        await exec(['apt-get', 'install', '-y', 'git', 'curl', 'unzip', 'python3', 'make', 'g++']);
        
        // Install Bun (needed for test runner)
        await exec(['bash', '-c', 'curl -fsSL https://bun.sh/install | bash']);
        // Symlink bun/bunx to global path
        await exec(['ln', '-s', '/root/.bun/bin/bun', '/usr/local/bin/bun']);
        await exec(['ln', '-s', '/root/.bun/bin/bun', '/usr/local/bin/bunx']);
        
        // Configure Git (required for TGP tests)
        await exec(['git', 'config', '--global', 'user.email', 'test@example.com']);
        await exec(['git', 'config', '--global', 'user.name', 'Test User']);

        // 4. Setup Test Project
        await exec(['mkdir', '-p', '/app']);
        
        // Copy tarball
        console.log('[Docker] Copying artifacts...');
        await container.cp(tarballPath, '/app/tgp.tgz');
        
        // Copy tests (We only copy e2e as those are the consumer-facing tests)
        await exec(['mkdir', '-p', '/app/test']);
        await container.cp(path.join(projectRoot, 'test/e2e'), '/app/test/e2e');
        await container.cp(path.join(projectRoot, 'test/integration'), '/app/test/integration');
        await container.cp(path.join(projectRoot, 'test/unit'), '/app/test/unit');
        await container.cp(path.join(projectRoot, 'test/fixtures'), '/app/test/fixtures');

        // Initialize Project & Install Package
        console.log('[Docker] Installing package...');
        await exec(['npm', 'init', '-y'], { cwd: '/app' });
        await exec(['npm', 'install', './tgp.tgz'], { cwd: '/app' });
        // Install dev dependencies needed for the tests themselves
        await exec(['npm', 'install', '-D', 'bun-types', 'ai'], { cwd: '/app' });

        // DEBUG: Verify installation state
        console.log('[Docker] Verifying installation...');
        await exec(['cat', 'package.json'], { cwd: '/app' });
        await exec(['ls', '-F', 'node_modules'], { cwd: '/app' });

        // 5. Patch Test Files
        console.log('[Docker] Patching tests to use installed package...');
        
        // Inject the Utils Override
        const utilsOverridePath = path.join(os.tmpdir(), 'utils_override.ts');
        await fs.writeFile(utilsOverridePath, CONTAINER_UTILS_TS);
        await container.cp(utilsOverridePath, '/app/test/e2e/utils.ts');
        
        // Patch all tests to import from 'tool-generation-protocol' instead of relative paths
        // Regex matches ../../src/... paths
        const sedCmd = `find /app/test -name "*.test.ts" -type f -exec sed -i "s|\\.\\./\\.\\./src/[a-zA-Z0-9/._-]*|tool-generation-protocol|g" {} +`;
        await exec(['bash', '-c', sedCmd]);

        // 6. Run Tests
        console.log('[Docker] Running Tests...');
        const res = await container.exec(['bun', 'test', 'test/e2e/scenarios.test.ts', 'test/integration', 'test/unit'], { cwd: '/app' });
        
        const output = res.stdout + res.stderr;
        
        // Strict Verification: Parse the output for test counts
        // We strip ANSI codes just in case bun outputs colors
        // eslint-disable-next-line no-control-regex
        const cleanOutput = output.replace(/\u001b\[.*?m/g, ''); 

        const passMatch = cleanOutput.match(/(\d+)\s+pass/);
        const failMatch = cleanOutput.match(/(\d+)\s+fail/);

        if (!passMatch || !failMatch) {
            console.error('--------------- CONTAINER OUTPUT ---------------');
            console.error(output);
            console.error('------------------------------------------------');
            throw new Error('Could not parse test runner output. The test runner might have crashed or output format changed.');
        }

        const passCount = parseInt(passMatch[1], 10);
        const failCount = parseInt(failMatch[1], 10);

        // EXPLICIT LOGGING: Prove to the user that tests actually ran inside
        console.log(`[Docker] Inner Test Verification: ${passCount} passed, ${failCount} failed.`);

        if (res.exitCode !== 0 || failCount > 0 || passCount === 0) {
            console.error('--------------- TEST FAILURE ---------------');
            console.error(`Exit Code: ${res.exitCode}`);
            console.error(`Pass: ${passCount}, Fail: ${failCount}`);
            console.error('--------------- CONTAINER OUTPUT ---------------');
            console.error(output);
            console.error('------------------------------------------------');
        }

        expect(res.exitCode).toBe(0);
        expect(failCount).toBe(0);
        expect(passCount).toBeGreaterThan(0);
      }, TIMEOUT);
    });
  test/e2e/scenarios.test.ts: >-
    import { describe, it, expect, beforeEach, afterEach } from 'bun:test';

    import * as fs from 'fs/promises';

    import * as path from 'path';

    import { createTempDir, initBareRepo, createTgpConfig, runTgpCli, cleanupDir
    } from './utils.js';

    import { TGP } from '../../src/tgp.js';

    import { tgpTools } from '../../src/tools/index.js';

    import { createSqlTools } from '../../src/tools/sql.js';


    describe('E2E Scenarios', () => {
      let tempDir: string;
      let remoteRepo: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
        remoteRepo = await createTempDir('tgp-remote-');
        await initBareRepo(remoteRepo);
      });

      afterEach(async () => {
        await cleanupDir(tempDir);
        await cleanupDir(remoteRepo);
      });

      it('Scenario 1: Cold Start (Hydration, Fabrication, Execution)', async () => {
        // 1. Setup Config
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        
        // 2. Boot Kernel
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        
        const tools = tgpTools(kernel);

        // 3. Create a Tool (Fibonacci)
        const fibPath = 'tools/math/fib.ts';
        const fibCode = `
          export default function fib(args: { n: number }) {
            const n = args.n;
            if (n <= 1) return n;
            let a = 0, b = 1;
            for (let i = 2; i <= n; i++) {
              const temp = a + b;
              a = b;
              b = temp;
            }
            return b;
          }
        `;

        const writeRes = await tools.write_file.execute({ path: fibPath, content: fibCode });
        expect(writeRes.success).toBe(true);

        // 4. Validate Tool
        const checkRes = await tools.check_tool.execute({ path: fibPath });
        expect(checkRes.valid).toBe(true);

        // 5. Execute Tool
        const execRes = await tools.exec_tool.execute({ path: fibPath, args: { n: 10 } });
        expect(execRes.success).toBe(true);
        expect(execRes.result).toBe(55);

        // 6. Verify Persistence
        // Clone remote repo to a new dir and check file existence
        const verifyDir = await createTempDir('tgp-verify-');
        const { execSync } = await import('node:child_process');
        execSync(`git clone ${remoteRepo} .`, { cwd: verifyDir, stdio: 'ignore' });
        
        const exists = await fs.access(path.join(verifyDir, fibPath)).then(() => true).catch(() => false);
        expect(exists).toBe(true);

        await cleanupDir(verifyDir);
      });

      it('Scenario 2: Concurrency (The Merge Test)', async () => {
        // Agent A
        const dirA = await createTempDir('tgp-agent-a-');
        const configA = await createTgpConfig(dirA, remoteRepo);
        const kernelA = new TGP({ configFile: configA });
        await kernelA.boot();

        // Agent B
        const dirB = await createTempDir('tgp-agent-b-');
        const configB = await createTgpConfig(dirB, remoteRepo);
        const kernelB = new TGP({ configFile: configB });
        await kernelB.boot();

        const toolsA = tgpTools(kernelA);
        const toolsB = tgpTools(kernelB);

        // Both agents create different tools simultaneously
        // This forces one to fail the push, auto-rebase, and push again.
        await Promise.all([
          toolsA.write_file.execute({ 
            path: 'tools/tool_A.ts', 
            content: 'export default () => "A"' 
          }),
          toolsB.write_file.execute({ 
            path: 'tools/tool_B.ts', 
            content: 'export default () => "B"' 
          })
        ]);
        
        // Verify using a fresh Agent C
        const dirC = await createTempDir('tgp-agent-c-');
        const configC = await createTgpConfig(dirC, remoteRepo);
        const kernelC = new TGP({ configFile: configC });
        await kernelC.boot();
        
        const files = await kernelC.vfs.listFiles('tools');
        expect(files).toContain('tools/tool_A.ts');
        expect(files).toContain('tools/tool_B.ts');

        await cleanupDir(dirA);
        await cleanupDir(dirB);
        await cleanupDir(dirC);
      });

      it('Scenario 3: Refactor (Search & Replace)', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        const toolName = 'tools/greet.ts';
        await tools.write_file.execute({ 
          path: toolName, 
          content: `
    export default function(args: { name: string }) {
      return "hello " + args.name;
    }

    `
        });

        let res = await tools.exec_tool.execute({ path: toolName, args: { name: 'world' } });
        expect(res.result).toBe('hello world');

        await tools.apply_diff.execute({
          path: toolName,
          diff: `<<<<<<< SEARCH
      return "hello " + args.name;
    =======
      return "greetings " + args.name;
    >>>>>>> REPLACE`
        });

        res = await tools.exec_tool.execute({ path: toolName, args: { name: 'world' } });
        expect(res.result).toBe('greetings world');
      });

      it('Scenario 4: Resilience (Infinite Loop)', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        const badTool = 'tools/freeze.ts';
        await tools.write_file.execute({
          path: badTool,
          content: `export default function() { while(true) {} }`
        });

        const res = await tools.exec_tool.execute({ path: badTool, args: {} });
        expect(res.success).toBe(false);
        expect(res.error).toMatch(/timed out/i);
      });

      it('Scenario 5: Security (Jailbreak)', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        const hackTool = 'tools/hack.ts';
        await tools.write_file.execute({
          path: hackTool,
          content: `
            export default async function() {
               return await tgp.read_file('../../package.json');
            }
          `
        });

        const res = await tools.exec_tool.execute({ path: hackTool, args: {} });
        expect(res.success).toBe(false);
        expect(res.error).toMatch(/Security Violation/i);
      });

      it('Scenario 6: SQL Error Propagation', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);

        // Mock DB executor
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const mockExecutor = async (sql: string, _params: any[] = []) => {
          if (sql.includes('fail')) {
            throw new Error('Database Error');
          }
          return [];
        };

        const kernel = new TGP({ 
          configFile: configPath,
          sandboxAPI: { exec_sql: mockExecutor }
        });
        await kernel.boot();

        const tools = { ...tgpTools(kernel), ...createSqlTools(mockExecutor) };

        const dbTool = 'tools/db_ops.ts';
        await tools.write_file.execute({
          path: dbTool,
          content: `
            export default async function(args: { crash: boolean }) {
               if (args.crash) {
                  await tgp.exec_sql('SELECT * FROM users WHERE name = "fail"', []);
               }
            }
          `
        });

        const res = await tools.exec_tool.execute({ path: dbTool, args: { crash: true } });
        expect(res.success).toBe(false);
        expect(res.error).toContain('Database Error');
      });

      it('Scenario 9: Tool Composition (Orchestrator)', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        // 1. Create the Library Tool (The Dependency)
        const libPath = 'tools/lib/multiplier.ts';
        await tools.write_file.execute({
          path: libPath,
          content: `
            export default function multiply(a: number, b: number) {
              return a * b;
            }
          `
        });

        // 2. Create the Consumer Tool (The Orchestrator)
        const consumerPath = 'tools/calc.ts';
        // Note: We use require() because the sandbox environment uses CommonJS shim for inter-tool dependencies.
        await tools.write_file.execute({
          path: consumerPath,
          content: `
            const multiplier = require('./lib/multiplier').default;

            export default function calculate(args: { a: number, b: number }) {
              // Logic: (a * b) + 100
              const product = multiplier(args.a, args.b);
              return product + 100;
            }
          `
        });

        // 3. Execute
        const res = await tools.exec_tool.execute({ 
          path: consumerPath, 
          args: { a: 5, b: 5 } 
        });

        expect(res.success).toBe(true);
        expect(res.result).toBe(125); // (5 * 5) + 100
      });

      it('Scenario 10: Registry Integrity (Meta.json)', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        const docTool = 'tools/docs/roi.ts';
        const description = 'Calculates the Return on Investment based on cost and revenue.';
        
        // Write tool with JSDoc
        await tools.write_file.execute({
          path: docTool,
          content: `
            /**
             * ${description}
             */
            export default function roi(args: { cost: number, revenue: number }) {
              return (args.revenue - args.cost) / args.cost;
            }
          `
        });

        // Verify meta.json in the VFS backing store (on disk)
        // Note: The VFS root is at .tgp inside the tempDir
        const metaPath = path.join(tempDir, '.tgp/meta.json');
        const metaContent = await fs.readFile(metaPath, 'utf-8');
        const meta = JSON.parse(metaContent);

        expect(meta.tools[docTool]).toBeDefined();
        expect(meta.tools[docTool].description).toBe(description);
      });

      it('Scenario 11: Standards Enforcement (Linter)', async () => {
        const configPath = await createTgpConfig(tempDir, remoteRepo);
        const kernel = new TGP({ configFile: configPath });
        await kernel.boot();
        const tools = tgpTools(kernel);

        // Test 1: Magic Number
        const magicTool = 'tools/bad/magic.ts';
        await tools.write_file.execute({
          path: magicTool,
          content: `export default function(args: { x: number }) { return args.x * 9999; }`
        });

        let check = await tools.check_tool.execute({ path: magicTool });
        expect(check.valid).toBe(false);
        expect(check.errors.some((e: string) => e.includes('Magic Number'))).toBe(true);

        // Test 2: Hardcoded Secret
        const secretTool = 'tools/bad/secret.ts';
        await tools.write_file.execute({
          path: secretTool,
          content: `
            export default function() { 
              const apiKey = "sk-live-1234567890abcdef12345678"; 
              return apiKey;
            }
          `
        });

        check = await tools.check_tool.execute({ path: secretTool });
        expect(check.valid).toBe(false);
        expect(check.errors.some((e: string) => e.includes('Secret'))).toBe(true);

        // Test 3: Valid Tool (Control)
        const validTool = 'tools/good/clean.ts';
        await tools.write_file.execute({
          path: validTool,
          content: `export default function(args: { factor: number }) { return args.factor * 100; }` // 100 is allowed
        });

        check = await tools.check_tool.execute({ path: validTool });
        expect(check.valid).toBe(true);
      });

      // Note: Scenario 7 (SIGTERM) is skipped as the CLI currently does not have a long-running 'serve' mode to test against.

      it('Scenario 8: CLI Bootstrap', async () => {
        // We assume the project has been built via 'npm run build' for bin/tgp.js to work
        // If not, this test might fail if dist/ doesn't exist.
        const { code, stderr } = await runTgpCli(['init'], tempDir);
        if (code !== 0) {
          console.error('CLI Bootstrap Failed:', stderr);
        }
        expect(code).toBe(0);
        
        const configExists = await fs.access(path.join(tempDir, 'tgp.config.ts')).then(() => true).catch(() => false);
        expect(configExists).toBe(true);
        
        const metaExists = await fs.access(path.join(tempDir, '.tgp/meta.json')).then(() => true).catch(() => false);
        expect(metaExists).toBe(true);
      });
    });
approved: true
linesAdded: 114
linesRemoved: 13
linesDifference: 127
gitCommittedAt: null
status: committed
id: 95

uuid: c888e7b1-4f10-410c-99b8-ec371587d4f9
projectId: tool-generation-protocol
createdAt: '2025-11-28T14:07:41.736Z'
gitCommitMsg: >-
  docs: replace patch_file with apply_diff in system prompt and readme

  Updates the "EXECUTION FLOW" in the system prompt and the tool list in the
  README to reflect the replacement of the `patch_file` tool with the more
  robust `apply_diff`.
promptSummary: Update System Prompt and README to replace patch_file with apply_diff.
reasoning:
  - 'Step 1: Update System Prompt in `src/tgp.ts` to include `apply_diff` usage.'
  - 'Step 2: Update `README.md` to reflect the new tool signature and usage.'
operations:
  - type: write
    path: src/tgp.ts
    content: |
      --- src/tgp.ts
      +++ src/tgp.ts
      @@ -124,5 +124,6 @@
       2.  Read file content to understand the tool.
       3.  If missing, write_file to create a new tool.
      -4.  Use check_tool to validate syntax.
      -5.  Use exec_tool to run it.
      +4.  If buggy, apply_diff to fix it (Search/Replace or Unified Diff).
      +5.  Use check_tool to validate syntax.
      +6.  Use exec_tool to run it.
       `;
         }
    patchStrategy: standard-diff
  - type: write
    path: README.md
    content: >
      --- README.md

      +++ README.md

      @@ -69,5 +69,5 @@
       | **`read_file`** | `(path: string) => string` | Read the content of an existing tool or schema. |
       | **`write_file`** | `(path: string, content: string) => void` | Create a new tool or overwrite a draft. |
      -| **`patch_file`** | `(path: string, search: string, replace: string) =>
      void` | Surgical search-and-replace for refactoring. |

      +| **`apply_diff`** | `(path: string, diff: string) => void` | Apply a
      Unified Diff or Search/Replace block to a file. |
       | **`check_tool`** | `(path: string) => { valid: boolean, errors: string[] }` | Run the JIT compiler and linter. |
       | **`exec_tool`** | `(path: string, args: object) => any` | Execute a tool inside the secure Sandbox. |
      @@ -98,5 +98,5 @@
       2.  **Diagnose**: Agent identifies the logic error or schema mismatch.
      -3.  **Patch**: Agent uses `patch_file` to fix the code in place.

      +3.  **Patch**: Agent uses `apply_diff` to fix the code in place.
       4.  **Verify**: Agent runs `check_tool`.
       
    patchStrategy: standard-diff
snapshot:
  src/tgp.ts: >-
    import * as fs from 'node:fs';

    import * as http from 'isomorphic-git/http/node';

    import { createKernel, Kernel, KernelEnvironment } from './kernel/core.js';

    import { loadTGPConfig } from './config.js';

    import { createNodeVFS } from './vfs/node.js';

    import { TGPConfigSchema, TGPConfig, Logger } from './types.js';

    import { VFSAdapter } from './vfs/types.js';

    import { GitBackend } from './kernel/git.js';

    import { Registry } from './kernel/registry.js';


    export interface TGPOptions {
      /**
       * Path to the configuration file.
       * @default "./tgp.config.ts"
       */
      configFile?: string;

      /**
       * Override the Virtual Filesystem Adapter.
       * Useful for using MemoryVFS in tests or Edge environments.
       * If omitted, defaults to NodeVFS rooted at config.rootDir.
       */
      vfs?: VFSAdapter;

      /**
       * Inject a custom logger. Defaults to console.
       */
      logger?: Logger;

      /**
       * Override the raw filesystem used by Git.
       * If omitted, defaults to 'node:fs'.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      fs?: any;

      /**
       * Override the HTTP client used by Git.
       * If omitted, defaults to 'isomorphic-git/http/node'.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      http?: any;

      /**
       * Custom functions to inject into the Sandbox global 'tgp' object.
       * e.g. { exec_sql: (sql) => db.query(sql) }
       */
      sandboxAPI?: Record<string, any>;
    }


    /**
     * The TGP Kernel Class.
     * Manages the lifecycle of the Agent's runtime environment, including
     * configuration, filesystem (VFS), Git persistence, and the Tool Registry.
     */
    export class TGP implements Kernel {
      public config: TGPConfig;
      public vfs: VFSAdapter;
      public git: GitBackend;
      public registry: Registry;
      public logger: Logger;
      public sandboxAPI: Record<string, any>;
      
      private _isBooted = false;

      constructor(private opts: TGPOptions = {}) {
        // 1. Initialize with Defaults (Sync)
        // We use the default schema to ensure the kernel is usable immediately (e.g. for tooling)
        // even before the async config load completes.
        this.config = TGPConfigSchema.parse({});
        
        // 2. Setup VFS
        // Use injected VFS or default to Node VFS
        this.vfs = opts.vfs || createNodeVFS(this.config.rootDir);

        // 3. Setup Sandbox API
        this.sandboxAPI = opts.sandboxAPI || {};

        // 3. Initialize Kernel Components
        // Construct Environment with defaults if not provided
        const env: KernelEnvironment = {
          fs: opts.fs || fs,
          http: opts.http || http
        };

        const kernel = createKernel({
          config: this.config,
          vfs: this.vfs,
          env,
          logger: opts.logger,
          sandboxAPI: this.sandboxAPI
        });

        this.git = kernel.git;
        this.registry = kernel.registry;
        this.logger = kernel.logger;
      }

      /**
       * Hydrates the Kernel from the configuration file and Git.
       * This must be awaited before executing tools in production.
       */
      async boot(): Promise<void> {
        if (this._isBooted) return;

        const configPath = this.opts.configFile || './tgp.config.ts';

        try {
          // 1. Load Real Configuration
          const loadedConfig = await loadTGPConfig(configPath);
          this.config = loadedConfig;

          // 2. Re-initialize VFS if RootDir changed AND user didn't inject a custom VFS
          // If the user injected a VFS, we assume they configured it correctly.
          if (!this.opts.vfs) {
            this.vfs = createNodeVFS(this.config.rootDir);
          }

          // 3. Re-initialize Kernel Components with new Config/VFS
          const env: KernelEnvironment = {
            fs: this.opts.fs || fs,
            http: this.opts.http || http
          };

          const kernel = createKernel({
            config: this.config,
            vfs: this.vfs,
            env,
            logger: this.opts.logger,
            sandboxAPI: this.sandboxAPI
          });
          
          this.git = kernel.git;
          this.registry = kernel.registry;

          // 4. Hydrate State (Git Clone/Pull + Registry Build)
          await kernel.boot();
          
          this._isBooted = true;
        } catch (error) {
          // If config loading fails, we might still be in a valid default state,
          // but we should warn the user.
          console.warn(`[TGP] Boot warning:`, error);
          throw error;
        }
      }

      async shutdown(): Promise<void> {
        // Passthrough to internal kernel shutdown if needed
        this._isBooted = false;
      }

      /**
       * Generates the System Prompt enforcing the "8 Standards" and TGP protocol.
       */
      getSystemPrompt(): string {
        return `
    You are an autonomous AI Engineer running on the Tool Generation Protocol
    (TGP).

    Your goal is to build, validate, and execute tools to solve the user's
    request.


    # THE PROTOCOL


    1.  **Reuse or Forge**: Check if a tool exists. If not, write it.

    2.  **No One-Offs**: Do not execute arbitrary scripts. Create a reusable
    tool in 'tools/'.

    3.  **Strict Typing**: All tools must be written in TypeScript. No 'any', no
    'unknown'.

    4.  **Database Interaction**: You MUST use the 'exec_sql' tool to interact
    with the database. Do not write tools that attempt to connect to a database
    themselves.


    # CODING STANDARDS (The 8 Commandments)


    1.  **Abstract**: Logic must be separated from data. (e.g., args.taxRate,
    not 0.05).

    2.  **Composable**: Functions should return results usable by others.

    3.  **HOFs**: Use map/reduce/filter over imperative loops.

    4.  **Stateless**: No global state. No reliance on previous execution.

    5.  **Reusable**: Generic enough for multiple use cases.

    6.  **General by Params**: Behavior controlled by arguments.

    7.  **No Hardcoded Values**: No magic numbers or IDs.

    8.  **Orchestrator**: Tools can import other tools via 'require'.


    # EXECUTION FLOW


    1.  List files to see what you have.

    2.  Read file content to understand the tool.

    3.  If missing, write_file to create a new tool.

    4.  Use check_tool to validate syntax.

    5.  Use exec_tool to run it.

    `;
      }
    }
  README.md: >
    # Tool Generation Protocol (TGP)


    > **The Self-Assembling Backend.**

    > **MCP is dead.** Stop streaming context. Start compiling tools.


    # 1. Manifesto


    **The Problem:** You spend 80% of your time writing "glue code"—RPCs, CRUD
    wrappers, and slightly different "Export to CSV" endpoints.

    **The Trap (MCP):** Model Context Protocol (MCP) is just better glue. It
    requires you to pre-build tools. If you didn't write the endpoint, the Agent
    fails.

    **The Solution (TGP):** Give the Agent a compiler.


    TGP is a **JIT Runtime for Business Logic**. The Agent forges its own tools,
    validates them, and persists them to Git. It builds a personalized standard
    library for your application.


    *   **MCP**: "I can't do that. I don't have a tool."

    *   **TGP**: "I wrote a tool. It's running."


    ## 1.1 Use Cases (The Long Tail)


    99% of features are never built because they are too specific. TGP solves
    the "I wish the app could do X" problem.


    *   **Reporting**: "List users who downgraded in June, pipe-delimited." ->
    Forges `tools/reports/downgrade.ts`. Time: 4s.

    *   **Cleanup**: "Fix typo in 'Ohiio' for active users." -> Forges
    `tools/maintenance/fix_typo.ts`. Atomic SQL update.

    *   **Logic**: "Calculate dimensional weight `(L*W*H)/139`." -> Forges
    `tools/shipping/dim_weight.ts`. Deterministic V8 execution.


    ## 1.2 Anti-Patterns


    TGP is a **JIT Compiler**, not a Daemon.

    *   **Not a Server**: No `express.listen()`. Tools are ephemeral
    (Lambda-style).

    *   **Not a Browser**: No DOM. No Puppeteer.

    *   **Not an ORM**: No object mutation. Use raw, atomic SQL.


    # 2. Architecture (The Stack)


    TGP drops into your existing Node/Next.js/Nest apps. It is **just
    TypeScript**.


    ## 2.1 The Developer View


    The agent views `./.tgp` as its root directory. This is a standard Git
    repository.


    ```bash

    ./.tgp/

    ├── .git/                  # MEMORY: Version history of TOOL SOURCE CODE.

    ├── bin/                   # KERNEL: The compiled 'tgp' binary.

    ├── tools/                 # USER SPACE: Generated capabilities.

    │   ├── analytics/         # e.g., "churn-prediction.ts"

    │   └── reports/           # e.g., "revenue-csv.ts"

    └── meta.json              # REGISTRY: Fast lookup index.

    ```


    ## 2.2 GitOps & Serverless Harmony


    **Is TGP Serverless Friendly?** Yes.


    In a Serverless environment (Cloudflare Workers, AWS Lambda, Vercel), the
    runtime filesystem is ephemeral. TGP handles this by treating **Git as the
    Backend**.


    1.  **Hydration**: On boot, TGP checks if the local cache matches the remote
    `HEAD`. If not, it pulls the latest tools from GitHub/GitLab.

    2.  **Execution**: Tools run in the local V8 Isolate (milliseconds).

    3.  **Persistence**: When an Agent forges a new tool, it commits and pushes
    to the remote repository.

    4.  **Concurrency**: TGP uses standard Git locking to handle concurrent
    writes from multiple agents.


    *Configuring GitHub credentials enables the "Infinite Memory" feature.*


    ## 2.3 The VFS (Virtual Filesystem)


    TGP enforces a strict separation between **The Editor (Host)** and **The
    Runtime (Sandbox)**.


    1.  **The Editor (Agent Context)**: The Agent accesses `./.tgp` directly via
    the Kernel Tools. It works just like a human dev using VS Code.

    2.  **The Runtime (Sandbox Context)**: When code *executes*, it runs inside
    the V8 Isolate with a restricted VFS:
        *   **`/lib`**: Read-Only mount of Host's `./.tgp/tools`.
        *   **`/tmp`**: Read-Write ephemeral scratchpad (wiped on exit).

    ## 2.4 The Kernel Tools (Agent Capabilities)


    The Agent is provided with a specific set of primitives to interact with the
    environment. It does not have generic shell access.


    | Tool | Signature | Description |

    | :--- | :--- | :--- |

    | **`list_files`** | `(dir: string) => string[]` | Recursively list
    available tools or definitions. |

    | **`read_file`** | `(path: string) => string` | Read the content of an
    existing tool or schema. |

    | **`write_file`** | `(path: string, content: string) => void` | Create a
    new tool or overwrite a draft. |

    | **`patch_file`** | `(path: string, search: string, replace: string) =>
    void` | Surgical search-and-replace for refactoring. |

    | **`check_tool`** | `(path: string) => { valid: boolean, errors: string[]
    }` | Run the JIT compiler and linter. |

    | **`exec_tool`** | `(path: string, args: object) => any` | Execute a tool
    inside the secure Sandbox. |

    | **`exec_sql`**   | `(sql: string, params: object) => any` | Executes a raw
    SQL query against the host database. |


    ---


    # 3. The Protocol


    This is the algorithm the Agent must follow. It is the "software" running on
    the Agent's "CPU".


    ## 3.1 The Prime Directive: "Reuse or Forge"


    The Agent is forbidden from executing one-off scripts for repetitive tasks.


    1.  **Lookup**: Query registry. If a tool exists (Score > 0.85), **Reuse**.

    2.  **Forge**: If no tool exists, **Create**.

    3.  **Persist**: Commit to Git.


    ## 3.2 The 8 Standards of Code Quality


    To ensure the ecosystem remains clean, the Agent must adhere to strict code
    quality guidelines. The Linter/Reviewer will reject tools that violate these
    principles.


    1.  **Abstract**: Logic must be separated from specific data instances.
        *   *Bad*: `const tax = 0.05`
        *   *Good*: `const tax = args.taxRate`
    2.  **Composable**: Functions should do one thing and return a result usable
    by other functions.

    3.  **HOFs (Higher Order Functions)**: Use map/reduce/filter patterns rather
    than imperative loops where possible.

    4.  **Stateless**: Tools must not rely on variables outside their scope or
    previous executions.

    5.  **Reusable**: The code should be generic enough to serve multiple use
    cases.

    6.  **General by Params**: Behavior is controlled by arguments, not
    hardcoded strings.

    7.  **No Hardcoded Values**: No magic numbers, no specific IDs, no emails in
    source code.

    8.  **Orchestrator Capable**: Tools should be able to import and invoke
    other TGP tools (via the `require` bridge).


    ## 3.3 The Feedback Loop (Self-Healing)


    If a tool fails during execution:

    1.  **Capture**: Agent reads STDERR.

    2.  **Diagnose**: Agent identifies the logic error or schema mismatch.

    3.  **Patch**: Agent uses `patch_file` to fix the code in place.

    4.  **Verify**: Agent runs `check_tool`.


    ---


    # 4. Security (The Sandbox)


    **TL;DR:**

    1.  **Zero-Trust**: Tools run in a stripped V8 context. No `process`, no
    `fs`, no `eval`.

    2.  **Resource Caps**: 64MB RAM, 50ms CPU time. Infinite loops die
    instantly.

    3.  **Transaction Safety**: All DB writes run inside a transaction. If the
    tool throws, the DB rolls back.


    ## 4.1 The Great Wall (isolated-vm)

    TGP uses `isolated-vm` to create a boundary between the Host (Agent) and the
    Guest (Tool).

    *   **Memory**: Separate Heaps.

    *   **Syscalls**: Bridged via specific `tgp` global object.

    *   **Network**: Blocked by default. Allowed only via whitelisted `fetch`
    bridge.


    ---


    # 5. The Ecosystem (Join the Hive)


    We are building the **`libc` of the AI Age**.


    ## 5.1 The Logic/State Split

    In TGP, **Tools are Stateless**.

    *   **Logic (Public)**: The TypeScript code
    (`tools/analytics/retention.ts`).

    *   **State (Private)**: The Database Connection (`DATABASE_URL`).


    ## 5.2 Hub & Spoke Topology (Git Backed)

    Because TGP relies on Git, your tools are portable.

    *   **Upstream**: A private repo (e.g., `github.com/org/tgp-global`).

    *   **Downstream**: The ephemeral serverless instances pull from Upstream.


    ---


    # 6. Governance Modes


    ## 6.1 God Mode (Development)

    *   **Behavior**: `Forge -> Compile -> Execute`.

    *   **Target**: Local `.tgp/` folder or direct push to `main`.


    ## 6.2 Gatekeeper Mode (Production)

    *   **Behavior**: `Forge -> Compile -> Pull Request`.

    *   **Target**: Agent creates a branch `feat/tool-name` and opens a PR.

    *   **Approval**: A human or a Senior Agent reviews the diff before merging
    to `main`.


    ---


    # 7. Integration Spec


    ## 7.1 The Bootstrap

    ```bash

    npx tool-generation-protocol@latest init

    ```


    ## 7.2 Configuration (`tgp.config.ts`)


    The configuration defines the Sandbox boundaries and the Git backend.


    ```typescript

    import { defineTGPConfig } from 'tool-generation-protocol';


    export default defineTGPConfig({
      // The Root of the Agent's filesystem (Ephemeral in serverless)
      rootDir: './.tgp',

      // 1. BACKEND (GitOps)
      // Essential for Serverless/Ephemeral environments.
      // The Agent pulls state from here and pushes new tools here.
      git: {
        provider: 'github', // or 'gitlab', 'bitbucket'
        repo: 'my-org/tgp-tools',
        branch: 'main',
        auth: {
          // Why not in config? Because we read from ENV for security.
          token: process.env.TGP_GITHUB_TOKEN,
          user: 'tgp-bot[bot]',
          email: 'tgp-bot@users.noreply.github.com'
        },
        // Strategy: 'direct' (push) or 'pr' (pull request)
        writeStrategy: process.env.NODE_ENV === 'production' ? 'pr' : 'direct'
      },

      // 2. FILESYSTEM JAIL
      fs: {
        allowedDirs: ['./public/exports', './tmp'],
        blockUpwardTraversal: true
      },

      // 3. RUNTIME
      allowedImports: ['@tgp/std', 'zod', 'date-fns'],

      // 4. NETWORKING
      // Whitelist of URL prefixes the sandbox fetch can access.
      allowedFetchUrls: ['https://api.stripe.com']
    });

    ```


    ## 7.3 Runtime Usage (The SDK)


    ```typescript

    // src/app/api/agent/route.ts

    import { TGP, tgpTools, createSqlTools } from 'tool-generation-protocol';

    import { generateText } from 'ai';

    import { myDbExecutor } from '@/lib/db'; // Your DB connection


    const kernel = new TGP({ configFile: './tgp.config.ts' });


    export async function POST(req: Request) {
      const { messages } = await req.json();

      // Injects: list_files, read_file, write_file, exec_tool
      const systemTools = tgpTools(kernel);
      // Injects the `exec_sql` tool, powered by your database
      const dataTools = createSqlTools(myDbExecutor);

      const result = await generateText({
        model: openai('gpt-4-turbo'),
        tools: { ...systemTools, ...dataTools },
        messages,
        // The System Prompt enforces the "8 Standards"
        system: kernel.getSystemPrompt() 
      });

      return result.response;
    }

    ```


    ---


    # 8. Roadmap & Contributing


    We are hacking on the future of backend development.


    *   **[P0] The LSP**: IDE extension for real-time tool visibility.

    *   **[P1] Vector Memory**: Semantic search for tool reuse.

    *   **[P2] Multi-Lang**: Python support via WebAssembly.


    **Get Involved:**

    `git clone` -> `npm install` -> `npm run forge`.

    ```
approved: true
linesAdded: 5
linesRemoved: 4
linesDifference: 9
gitCommittedAt: '2025-11-28T14:10:25.784Z'
status: committed
id: 79

uuid: c8f32e9a-7b1d-48d2-94a1-b5d3c8c6f1a9
projectId: tool-generation-protocol
createdAt: '2025-11-29T08:47:26.824Z'
gitCommitMsg: >-
  test: harden docker verification logic with strict output parsing

  Replaces loose string matching with regex-based parsing of 'bun test' stats to
  ensure zero failures occurred inside the container.
promptSummary: >-
  I updated the Docker E2E test to strictly parse the test runner output for
  "pass" and "fail" counts, ensuring 0 failures and >0 passes, and to log the
  full output on failure.
reasoning:
  - >-
    To ensure the Docker compatibility tests are strictly verifying success (and
    not just exiting with code 0 or matching a loose string), I will implement
    strict parsing of the test runner's output. This will fail the test if the
    container reports any failures, or if it fails to report any passes (e.g.,
    if the test runner crashed silently).
  - '### 1. Harden Docker Verification Logic'
  - 'I will update `test/docker/npm-compat.test.ts` to:'
  - 1.  Capture the combined `stdout` and `stderr` from the container.
  - 2.  Strip ANSI color codes to ensure clean regex matching.
  - >-
    3.  Parse the `X pass` and `Y fail` statistics typically output by `bun
    test`.
  - 4.  Assert that `failCount` is strictly 0 and `passCount` is greater than 0.
  - >-
    5.  Log the full container output if any of these checks fail, aiding in
    debugging.
operations:
  - type: write
    path: test/docker/npm-compat.test.ts
    content: >
      --- test/docker/npm-compat.test.ts

      +++ test/docker/npm-compat.test.ts

      @@ -107,11 +107,26 @@
           console.log('[Docker] Running Tests...');
           const res = await container.exec(['bun', 'test', 'test/e2e/scenarios.test.ts'], { cwd: '/app' });
           
      -    if (res.exitCode !== 0) {

      -        console.error('STDOUT:', res.stdout);

      -        console.error('STDERR:', res.stderr);

      +    const output = res.stdout + res.stderr;

      +    

      +    // Strict Verification: Parse the output for test counts

      +    // We strip ANSI codes just in case bun outputs colors

      +    // eslint-disable-next-line no-control-regex

      +    const cleanOutput = output.replace(/\u001b\[.*?m/g, ''); 

      +

      +    const passMatch = cleanOutput.match(/(\d+)\s+pass/);

      +    const failMatch = cleanOutput.match(/(\d+)\s+fail/);

      +

      +    if (!passMatch || !failMatch) {

      +        console.error('--------------- CONTAINER OUTPUT
      ---------------');

      +        console.error(output);

      +       
      console.error('------------------------------------------------');

      +        throw new Error('Could not parse test runner output. The test
      runner might have crashed or output format changed.');
           }
       
      +    const passCount = parseInt(passMatch[1], 10);

      +    const failCount = parseInt(failMatch[1], 10);

      +

      +    if (res.exitCode !== 0 || failCount > 0 || passCount === 0) {

      +        console.error('--------------- TEST FAILURE ---------------');

      +        console.error(`Exit Code: ${res.exitCode}`);

      +        console.error(`Pass: ${passCount}, Fail: ${failCount}`);

      +        console.error('--------------- CONTAINER OUTPUT
      ---------------');

      +        console.error(output);

      +       
      console.error('------------------------------------------------');

      +    }

      +
           expect(res.exitCode).toBe(0);
      -    const output = res.stdout + res.stderr;

      -    expect(output.toLowerCase()).toContain('pass');

      +    expect(failCount).toBe(0);

      +    expect(passCount).toBeGreaterThan(0);
         }, TIMEOUT);
       });
    patchStrategy: standard-diff
snapshot:
  test/docker/npm-compat.test.ts: >-
    import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach }
    from 'bun:test';

    import * as path from 'node:path';

    import * as fs from 'node:fs/promises';

    import * as os from 'node:os';

    import { createTarball, Container } from './utils.js';


    // Define the root of the project

    const projectRoot = path.resolve(__dirname, '../../');


    // Modified utils.ts to be injected into the container

    // This ensures tests use the installed package 'tool-generation-protocol' 

    // instead of trying to resolve local paths or dist/ folders.

    const CONTAINER_UTILS_TS = `

    import * as fs from 'node:fs/promises';

    import * as path from 'node:path';

    import * as os from 'node:os';

    import { spawn, execSync } from 'node:child_process';


    const tempDirs: string[] = [];


    // Create workspaces inside /app/test_workspaces to ensure they are within
    the project tree

    // where node_modules are installed (/app/node_modules). This fixes module
    resolution.

    const WORKSPACE_ROOT = '/app/test_workspaces';


    export async function createTempDir(prefix: string = 'tgp-e2e-'):
    Promise<string> {
      await fs.mkdir(WORKSPACE_ROOT, { recursive: true });
      const dir = await fs.mkdtemp(path.join(WORKSPACE_ROOT, prefix));
      tempDirs.push(dir);
      return dir;
    }


    export async function cleanupDir(dir: string): Promise<void> {
      await fs.rm(dir, { recursive: true, force: true }).catch(() => {});
    }


    export async function initBareRepo(dir: string): Promise<void> {
      await fs.mkdir(dir, { recursive: true });
      execSync(\`git init --bare\`, { cwd: dir, stdio: 'ignore' });
      const initDir = await createTempDir('tgp-init-');
      execSync(\`git init\`, { cwd: initDir, stdio: 'ignore' });
      await fs.writeFile(path.join(initDir, 'README.md'), '# Remote Root');
      execSync(\`git add .\`, { cwd: initDir, stdio: 'ignore' });
      execSync(\`git commit -m "Initial commit"\`, { cwd: initDir, stdio: 'ignore' });
      execSync(\`git remote add origin \${dir}\`, { cwd: initDir, stdio: 'ignore' });
      execSync(\`git push origin master:main\`, { cwd: initDir, stdio: 'ignore' });
      await cleanupDir(initDir);
      execSync(\`git symbolic-ref HEAD refs/heads/main\`, { cwd: dir, stdio: 'ignore' });
    }


    export async function createTgpConfig(workDir: string, remoteRepo: string,
    fileName: string = 'tgp.config.ts'): Promise<string> {
        const rootDir = path.join(workDir, '.tgp').split(path.sep).join('/');
        const remotePath = remoteRepo.split(path.sep).join('/');
        const allowedDir = workDir.split(path.sep).join('/');

        // OVERRIDE: Use the package name directly for imports
        const configContent = \`
    import { defineTGPConfig } from 'tool-generation-protocol';


    export default defineTGPConfig({
      rootDir: '\${rootDir}',
      git: {
        provider: 'local',
        repo: '\${remotePath}',
        branch: 'main',
        auth: { token: 'mock', user: 'test', email: 'test@example.com' }
      },
      fs: {
        allowedDirs: ['\${allowedDir}', '\${os.tmpdir().split(path.sep).join('/')}'],
        blockUpwardTraversal: false
      },
      allowedImports: ['zod', 'date-fns']
    });

    \`;
        const configPath = path.join(workDir, fileName);
        await fs.writeFile(configPath, configContent);
        return configPath;
    }


    export function runTgpCli(args: string[], cwd: string): Promise<{ stdout:
    string, stderr: string, code: number }> {
        return new Promise(async (resolve) => {
            // OVERRIDE: Use bunx tgp to execute the installed binary
            // Since we are running inside /app/test_workspaces, this should find local node_modules
            const proc = spawn('bunx', ['tgp', ...args], {
                cwd,
                env: { ...process.env, NODE_ENV: 'test' }
            });

            let stdout = '';
            let stderr = '';

            proc.stdout.on('data', d => stdout += d.toString());
            proc.stderr.on('data', d => stderr += d.toString());

            proc.on('close', (code) => {
                resolve({ stdout, stderr, code: code ?? -1 });
            });
        });
    }


    process.on('exit', () => {
        tempDirs.forEach(d => {
            try { execSync(\`rm -rf \${d}\`); } catch {}
        });
    });

    `;


    describe('Docker: NPM Compatibility', () => {
      let tarballPath: string;
      let container: Container;
      
      // High timeout for Docker operations
      const TIMEOUT = 120000; 

      beforeAll(async () => {
        // 1. Build the Tarball from source
        console.log('[Docker] Building NPM Tarball...');
        tarballPath = await createTarball(projectRoot);
        console.log(`[Docker] Tarball created at: ${tarballPath}`);
      });

      beforeEach(async () => {
        // 2. Start a fresh container
        container = new Container('oven/bun:1');
        await container.start();
        console.log(`[Docker] Container started: ${container.id}`);
      });

      afterEach(async () => {
        if (container) await container.stop();
      });

      afterAll(async () => {
        // Cleanup the local tarball
        if (tarballPath) await fs.rm(tarballPath, { force: true });
      });

      it('installs and runs E2E scenarios correctly', async () => {
        // 3. Prepare Environment inside Container
        console.log('[Docker] Installing dependencies (git)...');
        await container.exec(['apt-get', 'update']);
        await container.exec(['apt-get', 'install', '-y', 'git']);
        
        // Configure Git (required for TGP tests)
        await container.exec(['git', 'config', '--global', 'user.email', 'test@example.com']);
        await container.exec(['git', 'config', '--global', 'user.name', 'Test User']);

        // 4. Setup Test Project
        await container.exec(['mkdir', '-p', '/app']);
        
        // Copy tarball
        console.log('[Docker] Copying artifacts...');
        await container.cp(tarballPath, '/app/tgp.tgz');
        
        // Copy tests (We only copy e2e as those are the consumer-facing tests)
        await container.exec(['mkdir', '-p', '/app/test']);
        await container.cp(path.join(projectRoot, 'test/e2e'), '/app/test/e2e');

        // Initialize Project & Install Package
        console.log('[Docker] Installing package...');
        await container.exec(['bun', 'init', '-y'], { cwd: '/app' });
        await container.exec(['bun', 'add', './tgp.tgz'], { cwd: '/app' });
        // Install dev dependencies needed for the tests themselves
        await container.exec(['bun', 'add', '-d', 'bun-types'], { cwd: '/app' });

        // 5. Patch Test Files
        console.log('[Docker] Patching tests to use installed package...');
        
        // Inject the Utils Override
        const utilsOverridePath = path.join(os.tmpdir(), 'utils_override.ts');
        await fs.writeFile(utilsOverridePath, CONTAINER_UTILS_TS);
        await container.cp(utilsOverridePath, '/app/test/e2e/utils.ts');
        
        // Patch scenarios.test.ts to import from 'tool-generation-protocol' instead of relative paths
        // Regex matches ../../src/... paths
        const sedCmd = `sed -i "s|\\.\\./\\.\\./src/[a-zA-Z0-9/._-]*|tool-generation-protocol|g" /app/test/e2e/scenarios.test.ts`;
        await container.exec(['bash', '-c', sedCmd]);

        // 6. Run Tests
        console.log('[Docker] Running Tests...');
        const res = await container.exec(['bun', 'test', 'test/e2e/scenarios.test.ts'], { cwd: '/app' });
        
        if (res.exitCode !== 0) {
            console.error('STDOUT:', res.stdout);
            console.error('STDERR:', res.stderr);
        }

        expect(res.exitCode).toBe(0);
        const output = res.stdout + res.stderr;
        expect(output.toLowerCase()).toContain('pass');
      }, TIMEOUT);
    });
approved: true
linesAdded: 29
linesRemoved: 5
linesDifference: 34
gitCommittedAt: null
status: committed
id: 86

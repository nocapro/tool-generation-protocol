uuid: a8d59a88-75b4-49c0-b753-461320ef4255
projectId: tool-generation-protocol
createdAt: '2025-11-28T01:44:01.763Z'
gitCommitMsg: >-
  feat(sandbox): implement secure dependency injection for tools

  Introduces a synchronous, on-the-fly bundler using esbuild to securely provide
  whitelisted npm packages to sandboxed tools. The `allowedImports`
  configuration is now enforced.

  - A new `bundler.ts` module provides `bundleDependencySync` to JIT-bundle
  dependencies into CommonJS strings. Results are cached in memory. - The
  `executeTool` function's `require` bridge now intercepts bare module
  specifiers (e.g., 'zod'). - It validates the import against
  `config.allowedImports`, throwing a security violation if the module is not on
  the whitelist. - If allowed, the bundler is invoked, and the resulting code is
  executed within the sandbox. - This allows tools to safely use approved
  third-party libraries without compromising the integrity of the sandbox.
promptSummary: >-
  The user asked me to execute Part 2 of the refactoring plan, which involves
  implementing the `allowedImports` security feature for the sandbox.
reasoning:
  - Executing Part 2 of the plan to implement sandboxed imports.
  - '### Part 2: Implement `allowedImports` Sandboxing'
  - >-
    This part focuses on making the `allowedImports` configuration a real,
    working security feature. To do this, I will first create a synchronous
    bundler using `esbuild` that can resolve and package whitelisted npm modules
    on-the-fly. Then, I will integrate this bundler into the sandbox's `require`
    mechanism, allowing sandboxed tools to safely import dependencies like `zod`
    or `date-fns` while blocking any non-whitelisted modules.
  - '#### Step 1: Create a Synchronous Dependency Bundler'
  - >-
    First, I'll create a new file, `src/sandbox/bundler.ts`. This file will
    contain the `bundleDependencySync` function responsible for taking a package
    name, bundling it into a single CommonJS string using `esbuild`, and caching
    the result for performance. This synchronous API is critical for
    compatibility with the `isolated-vm` environment.
  - '#### Step 2: Integrate Bundler into Sandbox Module Loader'
  - >-
    Next, I'll modify `src/sandbox/execute.ts` to use the new bundler. The
    `__tgp_load_module` function, which acts as the bridge for `require` calls
    inside the sandbox, will be updated. It will now identify bare module
    specifiers (e.g., 'zod'), validate them against the `allowedImports` list in
    the TGP config, and if permitted, use the `bundleDependencySync` function to
    provide the module's code. Requests for relative or absolute file paths will
    continue to be resolved from the VFS as before.
operations:
  - type: write
    path: src/sandbox/bundler.ts
    content: >-
      import { buildSync } from 'esbuild';


      // In-memory cache to avoid redundant bundling of the same dependency
      within the kernel's lifetime.

      const bundleCache = new Map<string, string>();


      /**
       * Synchronously bundles a node module into a single CommonJS string.
       * This is used by the sandbox's 'require' shim to provide whitelisted dependencies.
       * 
       * @param dependency The name of the package to bundle (e.g., 'zod').
       * @returns The bundled JavaScript code as a string.
       */
      export function bundleDependencySync(dependency: string): string {
        if (bundleCache.has(dependency)) {
          return bundleCache.get(dependency)!;
        }

        try {
          const result = buildSync({
            entryPoints: [dependency],
            bundle: true,
            format: 'cjs',
            platform: 'node',
            write: false, // Return the output in memory
            logLevel: 'silent', // Suppress esbuild warnings in production logs
          });

          if (result.outputFiles && result.outputFiles.length > 0) {
            const bundledCode = result.outputFiles[0].text;
            bundleCache.set(dependency, bundledCode);
            return bundledCode;
          }

          throw new Error(`esbuild did not produce an output file for '${dependency}'.`);

        } catch (error) {
          // Re-throw with a more informative message for the host application logs
          const msg = error instanceof Error ? error.message : String(error);
          throw new Error(`Failed to resolve or bundle dependency '${dependency}': ${msg}`);
        }
      }
    patchStrategy: replace
  - type: write
    path: src/sandbox/execute.ts
    content: >+
      --- src/sandbox/execute.ts

      +++ src/sandbox/execute.ts

      @@ -1,6 +1,7 @@
       import { Kernel } from '../kernel/core.js';
       import { createSandbox } from './isolate.js';
       import { createSandboxBridge } from './bridge.js';
      +import { bundleDependencySync } from './bundler.js';
       import { transformSync } from 'esbuild';
       import * as path from 'path';
       
      @@ -35,12 +36,31 @@
           // 2. Module Orchestration (The 'require' Bridge)
           // This host function is called synchronously from the Guest.
           const __tgp_load_module = (baseDir: string, importId: string) => {
      +      // 1. Handle whitelisted node modules (bare specifiers)

      +      if (!importId.startsWith('.') && !importId.startsWith('/')) {

      +        if (!kernel.config.allowedImports.includes(importId)) {

      +          throw new Error(`Security Violation: Import of module
      '${importId}' is not allowed. Allowed modules are:
      ${kernel.config.allowedImports.join(', ')}`);

      +        }

      +        try {

      +          const bundledCode = bundleDependencySync(importId);

      +          return {

      +            code: bundledCode,

      +            path: `/__node_modules__/${importId}`, // Virtual path for
      caching

      +            dirname: `/__node_modules__`,

      +          };

      +        } catch (err: unknown) {

      +          const msg = err instanceof Error ? err.message : String(err);

      +          throw new Error(`Failed to bundle allowed module '${importId}':
      ${msg}`);

      +        }

      +      }

      +
             // Security: Ensure we don't traverse out of sandbox (handled by VFS)
             // Resolution Logic:
             // - Starts with '.': Relative to baseDir
             // - Otherwise: Absolute from root (or relative to root)
             
      -      let targetPath = '';

      +      let targetPath: string;
             if (importId.startsWith('.')) {
               targetPath = path.join(baseDir, importId);
             } else {

    patchStrategy: standard-diff
snapshot:
  src/sandbox/bundler.ts: null
  src/sandbox/execute.ts: >2-
     
    import { Kernel } from '../kernel/core.js';

    import { createSandbox } from './isolate.js';

    import { createSandboxBridge } from './bridge.js';

    import { transformSync } from 'esbuild';

    import * as path from 'path';


    export interface ExecutionResult {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      result: any;
      logs: string[];
      error?: string;
    }


    /**
     * Executes a tool script within a secure sandbox.
     * 
     * @param kernel The TGP Kernel instance
     * @param code The TypeScript source code of the tool
     * @param args The arguments object to pass to the tool (as 'args' global)
     * @param filePath Optional path of the tool being executed (used for relative imports)
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any

    export async function executeTool(kernel: Kernel, code: string, args:
    Record<string, any> = {}, filePath: string = 'root.ts'):
    Promise<ExecutionResult> {
      const sandbox = createSandbox({
        memoryLimitMb: 128,
        timeoutMs: 5000 // 5s hard limit
      });
      
      const logs: string[] = [];

      try {
        // 1. Setup Bridge
        // We pass the kernel directly.
        const bridge = createSandboxBridge({
          kernel,
          onLog: (msg) => logs.push(msg)
        });

        // 2. Module Orchestration (The 'require' Bridge)
        // This host function is called synchronously from the Guest.
        const __tgp_load_module = (baseDir: string, importId: string) => {
          // Security: Ensure we don't traverse out of sandbox (handled by VFS)
          // Resolution Logic:
          // - Starts with '.': Relative to baseDir
          // - Otherwise: Absolute from root (or relative to root)
          
          let targetPath = '';
          if (importId.startsWith('.')) {
            targetPath = path.join(baseDir, importId);
          } else {
            targetPath = importId;
          }

          // Normalize extension (assume .ts if missing)
          if (!targetPath.endsWith('.ts') && !targetPath.endsWith('.js')) {
              // Check if it exists with .ts
              // We can't easily check existence sync in VFS without try/catch read
              // Let's assume .ts for TGP tools
              targetPath += '.ts';
          }

          try {
            const raw = kernel.vfs.readSync(targetPath);
            const transformed = transformSync(raw, {
              loader: 'ts',
              format: 'cjs',
              target: 'es2020',
            });
            
            return {
              code: transformed.code,
              path: targetPath,
              dirname: path.dirname(targetPath)
            };
          } catch (err: unknown) {
            const msg = err instanceof Error ? err.message : String(err);
            throw new Error(`Failed to load module '${importId}' from '${baseDir}': ${msg}`);
          }
        };

        // 3. Shim Injection
        // We prepend a CommonJS loader shim to the user code.
        // This allows 'require' to work by calling back to the host via __tgp_load_module.
        // It includes a cache to prevent reloading the same module within a single execution.
        const shim = `
          const __moduleCache = {};

          function __makeRequire(baseDir) {
            return function(id) {
              // HOST INTERACTION: Resolve module path and get its source code from the host.
              // This is a synchronous call to the Node.js environment.
              const mod = __tgp_load_module.applySync(undefined, [baseDir, id]);

              // CACHE CHECK: If the module has already been loaded, return it from the cache.
              if (__moduleCache[mod.path]) {
                return __moduleCache[mod.path].exports;
              }

              // MODULE EXECUTION: If it's a new module, execute its code.
              const newModule = { exports: {} };

              // Before executing, store the module object in the cache to handle circular dependencies.
              __moduleCache[mod.path] = newModule;

              // We provide the module with its own 'exports' object, a 'require' function
              // scoped to its own directory, and other CommonJS globals.
              const fun = new Function('exports', 'require', 'module', '__filename', '__dirname', mod.code);

              // Execute the module's code.
              fun(newModule.exports, __makeRequire(mod.dirname), newModule, mod.path, mod.dirname);

              // The 'newModule.exports' object is now populated.
              return newModule.exports;
            };
          }

          // Setup Global Require for the entry point
          global.require = __makeRequire('${path.dirname(filePath)}');
        `;

        const context = {
          ...bridge, // { tgp: { ... } }
          args,
          __tgp_load_module // Injected as Reference
        };

        // Combine Shim + User Code
        // We wrap user code to provide top-level CommonJS variables if needed, 
        // but standard TGP tools are just scripts. 
        // We append the code. The 'shim' sets up 'global.require'.
        const fullScript = shim + '\n' + code;

        const result = await sandbox.compileAndRun(fullScript, context);
        return { result, logs };

      } catch (error) {
        const errMsg = error instanceof Error ? error.message : String(error);
        kernel.logger.error(`Tool Execution Failed:`, error);
        return { result: null, logs, error: errMsg };
      } finally {
        sandbox.dispose();
      }
    }
approved: true
linesAdded: 61
linesRemoved: 1
linesDifference: 62
gitCommittedAt: null
status: committed
id: 35

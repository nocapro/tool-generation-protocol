uuid: c8890947-f50c-449e-b8d4-d621b181e181
projectId: tool-generation-protocol
createdAt: '2025-11-27T10:24:03.807Z'
gitCommitMsg: >-
  feat: implement tool orchestration and transactional db

  - Added synchronous `readSync` to VFS for module loading. - Implemented
  `require` shim in Sandbox for calling other tools. - Added `src/kernel/db.ts`
  with Transactional Interface. - Wrapped tool execution in
  `kernel.db.transaction`. - Added `tgp_db_query` to bridge.
promptSummary: >-
  Implement Sandbox Module Orchestration (require) and Transactional Database
  Kernel.
reasoning: []
operations:
  - type: write
    path: src/vfs/types.ts
    content: |
      --- src/vfs/types.ts
      +++ src/vfs/types.ts
      @@ -15,6 +15,12 @@
          */
         readFile: (path: string) => Promise<string>;
       
      +  /**
      +   * Synchronously reads the content of a file.
      +   * Required for 'require' (synchronous module loading) in the Sandbox.
      +   */
      +  readSync: (path: string) => string;
      +
         /**
          * Writes content to a file. Creates parent directories if they don't exist.
          */
    patchStrategy: standard-diff
  - type: write
    path: src/vfs/node.ts
    content: |
      --- src/vfs/node.ts
      +++ src/vfs/node.ts
      @@ -1,4 +1,5 @@
       import * as fs from 'node:fs/promises';
      +import { readFileSync } from 'node:fs';
       import * as path from 'node:path';
       import { VFSAdapter } from './types.js';
       
      @@ -29,6 +30,11 @@
             return fs.readFile(fullPath, 'utf-8');
           },
       
      +    readSync(target: string): string {
      +      const fullPath = resolvePath(target);
      +      return readFileSync(fullPath, 'utf-8');
      +    },
      +
           async writeFile(target: string, content: string): Promise<void> {
             const fullPath = resolvePath(target);
             const dir = path.dirname(fullPath);
    patchStrategy: standard-diff
  - type: write
    path: src/vfs/memory.ts
    content: |
      --- src/vfs/memory.ts
      +++ src/vfs/memory.ts
      @@ -24,6 +24,15 @@
             return content;
           },
       
      +    readSync(target: string): string {
      +      const key = normalizePath(target);
      +      const content = store.get(key);
      +      if (content === undefined) {
      +        throw new Error(`File not found: ${target}`);
      +      }
      +      return content;
      +    },
      +
           async writeFile(target: string, content: string): Promise<void> {
             const key = normalizePath(target);
             store.set(key, content);
    patchStrategy: standard-diff
  - type: write
    path: src/kernel/db.ts
    content: |-
      /**
       * The Database Kernel Interface.
       * 
       * TGP guarantees that all tool executions happen within a transaction.
       * If the tool throws, the transaction is rolled back.
       */
      export interface DBBackend {
        /**
         * Executes a raw SQL query.
         * @param sql The SQL query string.
         * @param params Parameter substitutions.
         */
        query(sql: string, params?: any[]): Promise<any[]>;

        /**
         * Wraps a function in a database transaction.
         * @param fn The function to execute. It receives a transactional DB instance.
         */
        transaction<T>(fn: (trx: DBBackend) => Promise<T>): Promise<T>;
      }

      /**
       * A No-Op Database Backend used when no DB is configured.
       * It logs operations to the console to verify behavior.
       */
      export function createNoOpDB(): DBBackend {
        return {
          async query(sql: string, params: any[] = []) {
            console.log(`[TGP-DB] Query: ${sql}`, params);
            return [];
          },

          async transaction<T>(fn: (trx: DBBackend) => Promise<T>): Promise<T> {
            console.log(`[TGP-DB] Begin Transaction`);
            try {
              // In a real DB, we would start a trx here.
              // We pass 'this' as the transactional client (NoOp doesn't distinguish)
              const result = await fn(this);
              console.log(`[TGP-DB] Commit Transaction`);
              return result;
            } catch (err) {
              console.log(`[TGP-DB] Rollback Transaction`);
              throw err;
            }
          }
        };
      }
    patchStrategy: replace
  - type: write
    path: src/kernel/core.ts
    content: >
      --- src/kernel/core.ts

      +++ src/kernel/core.ts

      @@ -1,6 +1,7 @@
       import { TGPConfig } from '../types.js';
       import { VFSAdapter } from '../vfs/types.js';
       import { createGitBackend, GitBackend } from './git.js';
      +import { createNoOpDB, DBBackend } from './db.js';
       
       // We inject the low-level FS for Git separately from the VFS adapter
       // This is because Git needs raw FS access, while the Agent uses the VFS Jail.
      @@ -16,6 +17,7 @@
         config: TGPConfig;
         vfs: VFSAdapter;
         git: GitBackend;
      +  db: DBBackend;
       }
       
       /**
      @@ -26,12 +28,14 @@
         const { config, vfs, fs } = opts;
         
         const git = createGitBackend(fs, config);
      +  const db = createNoOpDB(); // TODO: Connect to real DB based on
      config.db
       
         let isBooted = false;
       
         return {
           config,
           vfs,
           git,
      +    db,
       
           async boot() {
             if (isBooted) return;
    patchStrategy: standard-diff
  - type: write
    path: src/sandbox/bridge.ts
    content: |
      --- src/sandbox/bridge.ts
      +++ src/sandbox/bridge.ts
      @@ -1,4 +1,5 @@
       import { Kernel } from '../kernel/core.js';
      +import { DBBackend } from '../kernel/db.js';
       
       /**
        * Creates the Bridge Object exposed to the Sandbox.
      @@ -7,7 +8,7 @@
        * NOTE: When passing functions to isolated-vm, arguments and return values 
        * must be serializable or wrapped in References.
        */
      -export function createSandboxBridge(kernel: Kernel) {
      +export function createSandboxBridge(kernel: Kernel, db: DBBackend) {
         const { vfs } = kernel;
       
         return {
      @@ -46,6 +47,11 @@
           // --- Logger ---
           tgp_log: (...args: any[]) => {
             console.log('[TGP-TOOL]', ...args);
      +    },
      +
      +    // --- Database (Transactional) ---
      +    tgp_db_query: async (sql: string, params: any[] = []) => {
      +      return db.query(sql, params);
           }
         };
       }
    patchStrategy: standard-diff
  - type: write
    path: src/sandbox/execute.ts
    content: >
      --- src/sandbox/execute.ts

      +++ src/sandbox/execute.ts

      @@ -1,29 +1,114 @@
       import { Kernel } from '../kernel/core.js';
       import { createSandbox } from './isolate.js';
       import { createSandboxBridge } from './bridge.js';
      +import { transformSync } from 'esbuild';

      +import * as path from 'path';
       
       /**
        * Executes a tool script within a secure sandbox.
        * 
        * @param kernel The TGP Kernel instance
        * @param code The TypeScript source code of the tool
        * @param args The arguments object to pass to the tool (as 'args' global)
      + * @param filePath Optional path of the tool being executed (used for
      relative imports)
        */
      -export async function executeTool(kernel: Kernel, code: string, args:
      Record<string, any> = {}): Promise<any> {

      +export async function executeTool(kernel: Kernel, code: string, args:
      Record<string, any> = {}, filePath: string = 'root.ts'): Promise<any> {
         const sandbox = createSandbox({
           memoryLimitMb: 128,
           timeoutMs: 5000 // 5s hard limit
         });
       
         try {
      -    const bridge = createSandboxBridge(kernel);

      -

      -    // Context Injection:

      -    // 1. The 'args' object (Input)

      -    // 2. The Bridge functions (Capabilities)

      -    const context = {

      -      args,

      -      ...bridge

      -    };

      -

      -    // We wrap the user code to ensure it can consume the 'args' and use
      the bridge.

      -    // The user code is expected to be a module or script. 

      -    // We wrap it in an IIFE to allow top-level execution flows if
      needed, 

      -    // but typically we expect a standard script execution.

      -    // 

      -    // We explicitly expose the bridge functions on the global scope by
      the isolate.ts logic.

      -    

      -    const result = await sandbox.compileAndRun(code, context);

      -    return result;

      +    // 1. Transactional Safety

      +    // All tool execution happens within a DB transaction.

      +    return await kernel.db.transaction(async (trx) => {

      +      const bridge = createSandboxBridge(kernel, trx);

      +

      +      // 2. Module Orchestration (The 'require' Bridge)

      +      // This host function is called synchronously from the Guest.

      +      const __tgp_load_module = (baseDir: string, importId: string) => {

      +        // Security: Ensure we don't traverse out of sandbox (handled by
      VFS)

      +        // Resolution Logic:

      +        // - Starts with '.': Relative to baseDir

      +        // - Otherwise: Absolute from root (or relative to root)

      +        

      +        let targetPath = '';

      +        if (importId.startsWith('.')) {

      +          targetPath = path.join(baseDir, importId);

      +        } else {

      +          targetPath = importId;

      +        }

      +

      +        // Normalize extension (assume .ts if missing)

      +        if (!targetPath.endsWith('.ts') && !targetPath.endsWith('.js')) {

      +           // Check if it exists with .ts

      +           // We can't easily check existence sync in VFS without
      try/catch read

      +           // Let's assume .ts for TGP tools

      +           targetPath += '.ts';

      +        }

      +

      +        try {

      +          const raw = kernel.vfs.readSync(targetPath);

      +          const transformed = transformSync(raw, {

      +            loader: 'ts',

      +            format: 'cjs',

      +            target: 'es2020',

      +          });

      +          

      +          return {

      +            code: transformed.code,

      +            path: targetPath,

      +            dirname: path.dirname(targetPath)

      +          };

      +        } catch (err: any) {

      +          throw new Error(`Failed to load module '${importId}' from
      '${baseDir}': ${err.message}`);

      +        }

      +      };

      +

      +      // 3. Shim Injection

      +      // We prepend a CommonJS loader shim to the user code.

      +      // This allows 'require' to work by calling back to
      __tgp_load_module.

      +      const shim = `

      +        const __moduleCache = {};

      +

      +        function __makeRequire(baseDir) {

      +          return function(id) {

      +            // Check Cache (Global)

      +            // In a real system, cache keys should be absolute paths.

      +            // Here we rely on the host to return consistent paths if we
      wanted perfect caching.

      +            // For now, we skip cache or use simple ID (flawed for
      relatives).

      +            // Let's implement correct caching by asking Host for
      absolute path first?

      +            // Simpler: Just reload for now (Stateless).

      +            

      +            // Call Host Sync

      +            const mod = __tgp_load_module.applySync(undefined, [baseDir,
      id]);

      +            

      +            if (__moduleCache[mod.path]) return __moduleCache[mod.path];

      +

      +            // Wrap in CommonJS Function

      +            const fun = new Function('exports', 'require', 'module',
      '__filename', '__dirname', mod.code);

      +            const newModule = { exports: {} };

      +            

      +            // Execute

      +            fun(newModule.exports, __makeRequire(mod.dirname), newModule,
      mod.path, mod.dirname);

      +            

      +            __moduleCache[mod.path] = newModule.exports;

      +            return newModule.exports;

      +          };

      +        }

      +        

      +        // Setup Global Require for the entry point

      +        // We assume the entry point is at 'filePath'

      +        global.require = __makeRequire('${path.dirname(filePath)}');

      +      `;

      +

      +      const context = {

      +        args,

      +        ...bridge,

      +        __tgp_load_module // Injected as Reference

      +      };

      +

      +      // Combine Shim + User Code

      +      // We wrap user code to provide top-level CommonJS variables if
      needed, 

      +      // but standard TGP tools are just scripts. 

      +      // We append the code. The 'shim' sets up 'global.require'.

      +      const fullScript = shim + '\n' + code;

      +

      +      const result = await sandbox.compileAndRun(fullScript, context);

      +      return result;

      +    });
       
         } catch (error) {
           console.error(`[TGP] Tool Execution Failed:`, error);
    patchStrategy: standard-diff
  - type: write
    path: src/tools/exec.ts
    content: |
      --- src/tools/exec.ts
      +++ src/tools/exec.ts
      @@ -25,7 +25,7 @@
               const code = await kernel.vfs.readFile(path);
               
               // The sandbox takes care of safety, timeout, and memory limits
      -        const result = await executeTool(kernel, code, args);
      +        const result = await executeTool(kernel, code, args, path);
               return result;
             },
           } as AgentTool<typeof ExecToolParams, any>,
    patchStrategy: standard-diff
snapshot:
  src/kernel/db.ts: null
  src/vfs/types.ts: |-
    /**
     * The Virtual Filesystem Adapter Interface.
     * 
     * TGP is designed to run in environments where a real filesystem might not exist 
     * (e.g., Cloudflare Workers, Edge Functions). The VFS abstracts I/O operations.
     * 
     * All paths provided to these methods are relative to the VFS root.
     */
    export interface VFSAdapter {
      /**
       * Reads the content of a file as a UTF-8 string.
       * Throws if file not found.
       */
      readFile: (path: string) => Promise<string>;

      /**
       * Writes content to a file. Creates parent directories if they don't exist.
       */
      writeFile: (path: string, content: string) => Promise<void>;

      /**
       * Deletes a file. Silent if file doesn't exist.
       */
      remove: (path: string) => Promise<void>;

      /**
       * Checks if a file exists.
       */
      exists: (path: string) => Promise<boolean>;

      /**
       * Lists files in a directory.
       * @param dir Relative path to directory.
       * @param recursive If true, lists all nested files.
       * @returns Array of relative paths (e.g., ['tools/a.ts', 'tools/sub/b.ts'])
       */
      listFiles: (dir: string, recursive?: boolean) => Promise<string[]>;
    }
  src/vfs/node.ts: |-
    import * as fs from 'node:fs/promises';
    import * as path from 'node:path';
    import { VFSAdapter } from './types.js';

    /**
     * Creates a VFS adapter backed by the physical disk.
     * Used for standard Node.js deployments and CLI tools.
     * 
     * @param rootDir The absolute or relative path to the sandbox root (e.g., ./.tgp)
     */
    export function createNodeVFS(rootDir: string): VFSAdapter {
      const absoluteRoot = path.resolve(rootDir);

      // Security: Ensure the target path is inside the rootDir
      const resolvePath = (target: string): string => {
        // Normalize and resolve against root
        const resolved = path.resolve(absoluteRoot, target);
        
        // Guard: Path Traversal Attack
        if (!resolved.startsWith(absoluteRoot)) {
          throw new Error(`Security Violation: Path '${target}' is outside the sandbox root.`);
        }
        return resolved;
      };

      return {
        async readFile(target: string): Promise<string> {
          const fullPath = resolvePath(target);
          return fs.readFile(fullPath, 'utf-8');
        },

        async writeFile(target: string, content: string): Promise<void> {
          const fullPath = resolvePath(target);
          const dir = path.dirname(fullPath);
          
          // Ensure directory exists (mkdir -p)
          await fs.mkdir(dir, { recursive: true });
          await fs.writeFile(fullPath, content, 'utf-8');
        },

        async remove(target: string): Promise<void> {
          const fullPath = resolvePath(target);
          // Silent failure if not exists, matching standard rm -f behavior
          await fs.rm(fullPath, { force: true }).catch(() => {}); 
        },

        async exists(target: string): Promise<boolean> {
          const fullPath = resolvePath(target);
          try {
            await fs.access(fullPath);
            return true;
          } catch {
            return false;
          }
        },

        async listFiles(dir: string, recursive: boolean = false): Promise<string[]> {
          const fullDir = resolvePath(dir);
          
          try {
            await fs.access(fullDir);
          } catch {
            return []; // Return empty if dir doesn't exist
          }

          const results: string[] = [];

          async function walk(currentDir: string, relativeBase: string) {
            const entries = await fs.readdir(currentDir, { withFileTypes: true });

            for (const entry of entries) {
              const entryPath = path.join(currentDir, entry.name);
              const relativePath = path.join(relativeBase, entry.name);

              if (entry.isDirectory()) {
                if (recursive) {
                  await walk(entryPath, relativePath);
                }
              } else {
                results.push(relativePath);
              }
            }
          }

          await walk(fullDir, dir);
          return results;
        }
      };
    }
  src/vfs/memory.ts: >-
    import { VFSAdapter } from './types.js';


    // Simple path normalizer for environments where 'path' module might be
    limited

    // or to ensure consistent behavior across platforms.

    function normalizePath(p: string): string {
      // Remove leading ./ and leading /
      return p.replace(/^(\.\/|\/)+/, '').replace(/\/+$/, '');
    }


    /**
     * Creates an ephemeral, in-memory VFS.
     * Used for Serverless execution or Unit Testing.
     */
    export function createMemoryVFS(initialFiles: Record<string, string> = {}):
    VFSAdapter {
      // Key: Normalized Path, Value: File Content
      const store = new Map<string, string>();

      // Initialize with seed data
      for (const [p, content] of Object.entries(initialFiles)) {
        store.set(normalizePath(p), content);
      }

      return {
        async readFile(target: string): Promise<string> {
          const key = normalizePath(target);
          const content = store.get(key);
          if (content === undefined) {
            throw new Error(`File not found: ${target}`);
          }
          return content;
        },

        async writeFile(target: string, content: string): Promise<void> {
          const key = normalizePath(target);
          store.set(key, content);
        },

        async remove(target: string): Promise<void> {
          const key = normalizePath(target);
          store.delete(key);
        },

        async exists(target: string): Promise<boolean> {
          const key = normalizePath(target);
          return store.has(key);
        },

        async listFiles(dir: string, recursive: boolean = false): Promise<string[]> {
          const normalizedDir = normalizePath(dir);
          const results: string[] = [];

          for (const key of store.keys()) {
            // Check if file is inside dir
            // We add a trailing slash to dir to ensure we match directory boundaries
            // e.g. dir="tools", key="tools/a.ts" -> match
            // e.g. dir="tool", key="tools/a.ts" -> no match
            
            // Handle root listing case
            const prefix = normalizedDir === '' ? '' : normalizedDir + '/';

            if (key.startsWith(prefix)) {
              const relativePart = key.slice(prefix.length);
              
              if (recursive) {
                results.push(key);
              } else {
                // If not recursive, ensure no more slashes in the remainder
                if (!relativePart.includes('/')) {
                  results.push(key);
                }
              }
            }
          }
          return results;
        }
      };
    }
  src/kernel/core.ts: >-
    import { TGPConfig } from '../types.js';

    import { VFSAdapter } from '../vfs/types.js';

    import { createGitBackend, GitBackend } from './git.js';


    // We inject the low-level FS for Git separately from the VFS adapter

    // This is because Git needs raw FS access, while the Agent uses the VFS
    Jail.

    export interface KernelOptions {
      config: TGPConfig;
      vfs: VFSAdapter; 
      fs: any; // The raw filesystem object (node:fs or memfs) used by isomorphic-git
    }


    export interface Kernel {
      boot(): Promise<void>;
      shutdown(): Promise<void>;
      config: TGPConfig;
      vfs: VFSAdapter;
      git: GitBackend;
    }


    /**
     * Factory to create a TGP Kernel.
     * This wires up the configuration, the filesystem, and the git backend.
     */
    export function createKernel(opts: KernelOptions): Kernel {
      const { config, vfs, fs } = opts;
      
      const git = createGitBackend(fs, config);

      let isBooted = false;

      return {
        config,
        vfs,
        git,

        async boot() {
          if (isBooted) return;
          console.log(`[TGP] Kernel booting...`);
          
          try {
            // Hydrate the filesystem from Git
            await git.hydrate();
            isBooted = true;
            console.log(`[TGP] Kernel ready.`);
          } catch (error) {
            console.error(`[TGP] Boot failed:`, error);
            throw error;
          }
        },

        async shutdown() {
          console.log(`[TGP] Kernel shutting down...`);
          // Cleanup tasks (close db connections, etc) can go here
          isBooted = false;
        }
      };
    }
  src/sandbox/bridge.ts: |-
    import { Kernel } from '../kernel/core.js';

    /**
     * Creates the Bridge Object exposed to the Sandbox.
     * This maps secure Kernel methods to the Guest environment.
     * 
     * NOTE: When passing functions to isolated-vm, arguments and return values 
     * must be serializable or wrapped in References.
     */
    export function createSandboxBridge(kernel: Kernel) {
      const { vfs } = kernel;

      return {
        // --- Filesystem Bridge (Jailed) ---
        // The Guest sees these as async functions on the global scope or a 'tgp' object.
        
        // tgp_read_file('./data.txt')
        tgp_read_file: async (path: string) => {
          // VFS already enforces jail path traversal checks
          return vfs.readFile(path);
        },

        // tgp_write_file('./output.txt', 'content')
        tgp_write_file: async (path: string, content: string) => {
          return vfs.writeFile(path, content);
        },

        // tgp_list_files('./tools')
        tgp_list_files: async (dir: string) => {
          return vfs.listFiles(dir, false);
        },

        // --- Network Bridge (Allowed Only) ---
        // We can inject a restricted fetch here.
        tgp_fetch: async (url: string, init?: any) => {
          // Security: Parse URL and allow-list check could happen here
          const response = await fetch(url, init);
          const text = await response.text();
          return {
            status: response.status,
            text: () => text,
            json: () => JSON.parse(text),
          };
        },

        // --- Logger ---
        tgp_log: (...args: any[]) => {
          console.log('[TGP-TOOL]', ...args);
        }
      };
    }
  src/sandbox/execute.ts: >-
    import { Kernel } from '../kernel/core.js';

    import { createSandbox } from './isolate.js';

    import { createSandboxBridge } from './bridge.js';


    /**
     * Executes a tool script within a secure sandbox.
     * 
     * @param kernel The TGP Kernel instance
     * @param code The TypeScript source code of the tool
     * @param args The arguments object to pass to the tool (as 'args' global)
     */
    export async function executeTool(kernel: Kernel, code: string, args:
    Record<string, any> = {}): Promise<any> {
      const sandbox = createSandbox({
        memoryLimitMb: 128,
        timeoutMs: 5000 // 5s hard limit
      });

      try {
        const bridge = createSandboxBridge(kernel);

        // Context Injection:
        // 1. The 'args' object (Input)
        // 2. The Bridge functions (Capabilities)
        const context = {
          args,
          ...bridge
        };

        // We wrap the user code to ensure it can consume the 'args' and use the bridge.
        // The user code is expected to be a module or script. 
        // We wrap it in an IIFE to allow top-level execution flows if needed, 
        // but typically we expect a standard script execution.
        // 
        // We explicitly expose the bridge functions on the global scope by the isolate.ts logic.
        
        const result = await sandbox.compileAndRun(code, context);
        return result;

      } catch (error) {
        console.error(`[TGP] Tool Execution Failed:`, error);
        throw new Error(`Tool execution failed: ${error instanceof Error ? error.message : String(error)}`);
      } finally {
        sandbox.dispose();
      }
    }
  src/tools/exec.ts: |-
    import { z } from 'zod';
    import { Kernel } from '../kernel/core.js';
    import { executeTool } from '../sandbox/execute.js';
    import { AgentTool } from './types.js';

    export const ExecToolParams = z.object({
      path: z.string().describe('The relative path of the tool to execute'),
      args: z.record(z.any()).describe('The arguments to pass to the tool'),
    });

    export function createExecTools(kernel: Kernel) {
      return {
        exec_tool: {
          description: 'Execute a tool inside the secure Sandbox.',
          parameters: ExecToolParams,
          execute: async ({ path, args }) => {
            // Security: Ensure args are serializable (no functions, no circular refs)
            // This prevents the agent from trying to pass internal objects to the guest.
            try {
              JSON.stringify(args);
            } catch {
              throw new Error("Arguments must be serializable JSON.");
            }

            const code = await kernel.vfs.readFile(path);
            
            // The sandbox takes care of safety, timeout, and memory limits
            const result = await executeTool(kernel, code, args);
            return result;
          },
        } as AgentTool<typeof ExecToolParams, any>,
      };
    }
approved: true
linesAdded: 180
linesRemoved: 20
linesDifference: 200
gitCommittedAt: null
status: committed
id: 15

uuid: c675f922-8399-4411-bdc2-9e2363191147
projectId: tool-generation-protocol
createdAt: '2025-11-27T09:20:07.972Z'
gitCommitMsg: >-
  feat: implement Virtual Filesystem (VFS) abstraction

  - Add VFSAdapter interface - Add NodeVFS for disk-based operations with jail
  security - Add MemoryVFS for ephemeral/serverless operations
promptSummary: >-
  Implemented Part 2 of the TGP Plan (The HAL). Created the VFS interface and
  two implementations (Node.js disk-backed and Memory-backed) to abstract file
  operations.
reasoning:
  - >-
    To execute Part 2, I will define the Virtual Filesystem (VFS) abstraction
    and implement two adapters: one for Node.js (disk-based) and one for
    Serverless (memory-based). This decouples the runtime from the
    infrastructure.
  - '### Step 1: Define VFS Protocol'
  - >-
    First, I define the contract that all filesystem adapters must adhere to.
    This uses a TypeScript `interface` to enforce the shape of the adapter
    object.
  - '### Step 2: Implement Node.js Adapter'
  - >-
    This adapter wraps `node:fs` and enforces security boundaries (`rootDir`).
    It ensures that an Agent cannot access files outside the `.tgp` directory
    (Jail).
  - '### Step 3: Implement In-Memory Adapter'
  - >-
    This adapter is for Serverless environments (like Cloudflare Workers) or
    testing. It mimics a filesystem using a `Map`. It performs path
    normalization to simulate directory structures.
operations:
  - type: write
    path: src/vfs/types.ts
    content: |-
      /**
       * The Virtual Filesystem Adapter Interface.
       * 
       * TGP is designed to run in environments where a real filesystem might not exist 
       * (e.g., Cloudflare Workers, Edge Functions). The VFS abstracts I/O operations.
       * 
       * All paths provided to these methods are relative to the VFS root.
       */
      export interface VFSAdapter {
        /**
         * Reads the content of a file as a UTF-8 string.
         * Throws if file not found.
         */
        readFile: (path: string) => Promise<string>;

        /**
         * Writes content to a file. Creates parent directories if they don't exist.
         */
        writeFile: (path: string, content: string) => Promise<void>;

        /**
         * Deletes a file. Silent if file doesn't exist.
         */
        remove: (path: string) => Promise<void>;

        /**
         * Checks if a file exists.
         */
        exists: (path: string) => Promise<boolean>;

        /**
         * Lists files in a directory.
         * @param dir Relative path to directory.
         * @param recursive If true, lists all nested files.
         * @returns Array of relative paths (e.g., ['tools/a.ts', 'tools/sub/b.ts'])
         */
        listFiles: (dir: string, recursive?: boolean) => Promise<string[]>;
      }
    patchStrategy: replace
  - type: write
    path: src/vfs/node.ts
    content: |-
      import * as fs from 'node:fs/promises';
      import * as path from 'node:path';
      import { VFSAdapter } from './types.js';

      /**
       * Creates a VFS adapter backed by the physical disk.
       * Used for standard Node.js deployments and CLI tools.
       * 
       * @param rootDir The absolute or relative path to the sandbox root (e.g., ./.tgp)
       */
      export function createNodeVFS(rootDir: string): VFSAdapter {
        const absoluteRoot = path.resolve(rootDir);

        // Security: Ensure the target path is inside the rootDir
        const resolvePath = (target: string): string => {
          // Normalize and resolve against root
          const resolved = path.resolve(absoluteRoot, target);
          
          // Guard: Path Traversal Attack
          if (!resolved.startsWith(absoluteRoot)) {
            throw new Error(`Security Violation: Path '${target}' is outside the sandbox root.`);
          }
          return resolved;
        };

        return {
          async readFile(target: string): Promise<string> {
            const fullPath = resolvePath(target);
            return fs.readFile(fullPath, 'utf-8');
          },

          async writeFile(target: string, content: string): Promise<void> {
            const fullPath = resolvePath(target);
            const dir = path.dirname(fullPath);
            
            // Ensure directory exists (mkdir -p)
            await fs.mkdir(dir, { recursive: true });
            await fs.writeFile(fullPath, content, 'utf-8');
          },

          async remove(target: string): Promise<void> {
            const fullPath = resolvePath(target);
            // Silent failure if not exists, matching standard rm -f behavior
            await fs.rm(fullPath, { force: true }).catch(() => {}); 
          },

          async exists(target: string): Promise<boolean> {
            const fullPath = resolvePath(target);
            try {
              await fs.access(fullPath);
              return true;
            } catch {
              return false;
            }
          },

          async listFiles(dir: string, recursive: boolean = false): Promise<string[]> {
            const fullDir = resolvePath(dir);
            
            try {
              await fs.access(fullDir);
            } catch {
              return []; // Return empty if dir doesn't exist
            }

            const results: string[] = [];

            async function walk(currentDir: string, relativeBase: string) {
              const entries = await fs.readdir(currentDir, { withFileTypes: true });

              for (const entry of entries) {
                const entryPath = path.join(currentDir, entry.name);
                const relativePath = path.join(relativeBase, entry.name);

                if (entry.isDirectory()) {
                  if (recursive) {
                    await walk(entryPath, relativePath);
                  }
                } else {
                  results.push(relativePath);
                }
              }
            }

            await walk(fullDir, dir);
            return results;
          }
        };
      }
    patchStrategy: replace
  - type: write
    path: src/vfs/memory.ts
    content: >-
      import { VFSAdapter } from './types.js';


      // Simple path normalizer for environments where 'path' module might be
      limited

      // or to ensure consistent behavior across platforms.

      function normalizePath(p: string): string {
        // Remove leading ./ and leading /
        return p.replace(/^(\.\/|\/)+/, '').replace(/\/+$/, '');
      }


      /**
       * Creates an ephemeral, in-memory VFS.
       * Used for Serverless execution or Unit Testing.
       */
      export function createMemoryVFS(initialFiles: Record<string, string> =
      {}): VFSAdapter {
        // Key: Normalized Path, Value: File Content
        const store = new Map<string, string>();

        // Initialize with seed data
        for (const [p, content] of Object.entries(initialFiles)) {
          store.set(normalizePath(p), content);
        }

        return {
          async readFile(target: string): Promise<string> {
            const key = normalizePath(target);
            const content = store.get(key);
            if (content === undefined) {
              throw new Error(`File not found: ${target}`);
            }
            return content;
          },

          async writeFile(target: string, content: string): Promise<void> {
            const key = normalizePath(target);
            store.set(key, content);
          },

          async remove(target: string): Promise<void> {
            const key = normalizePath(target);
            store.delete(key);
          },

          async exists(target: string): Promise<boolean> {
            const key = normalizePath(target);
            return store.has(key);
          },

          async listFiles(dir: string, recursive: boolean = false): Promise<string[]> {
            const normalizedDir = normalizePath(dir);
            const results: string[] = [];

            for (const key of store.keys()) {
              // Check if file is inside dir
              // We add a trailing slash to dir to ensure we match directory boundaries
              // e.g. dir="tools", key="tools/a.ts" -> match
              // e.g. dir="tool", key="tools/a.ts" -> no match
              
              // Handle root listing case
              const prefix = normalizedDir === '' ? '' : normalizedDir + '/';

              if (key.startsWith(prefix)) {
                const relativePart = key.slice(prefix.length);
                
                if (recursive) {
                  results.push(key);
                } else {
                  // If not recursive, ensure no more slashes in the remainder
                  if (!relativePart.includes('/')) {
                    results.push(key);
                  }
                }
              }
            }
            return results;
          }
        };
      }
    patchStrategy: replace
snapshot:
  src/vfs/types.ts: null
  src/vfs/node.ts: null
  src/vfs/memory.ts: null
approved: true
linesAdded: 204
linesRemoved: 0
linesDifference: 204
gitCommittedAt: null
status: committed
id: 2

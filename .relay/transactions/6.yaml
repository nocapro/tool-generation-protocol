uuid: c292a0d1-0985-48b2-b112-9c98a9c21183
projectId: tool-generation-protocol
createdAt: '2025-11-27T09:24:20.249Z'
gitCommitMsg: >-
  feat: implement Secure Sandbox (The Prison)

  - Add isolated-vm and esbuild for secure JIT execution - Implement
  createSandbox in src/sandbox/isolate.ts - Implement createSandboxBridge in
  src/sandbox/bridge.ts to expose VFS - Implement executeTool runner in
  src/sandbox/execute.ts
promptSummary: >-
  Implemented Part 4 (The Prison). Added isolated-vm and esbuild dependencies.
  Created the secure Sandbox factory, the Context Bridge to expose VFS/Kernel
  capabilities safely, and the Executor to run TypeScript tools JIT.
reasoning:
  - >-
    To execute Part 4, I will build the secure Sandbox "Prison". This relies on
    `isolated-vm` to provide V8 isolation (memory and CPU limits) and `esbuild`
    to transpile the TypeScript tools into JavaScript on the fly.
  - '### Step 1: Add Sandbox Dependencies'
  - >-
    I will add `isolated-vm` for the V8 sandbox and `esbuild` for the JIT
    compiler to `package.json`.
  - '### Step 2: The Sandbox Factory'
  - >-
    I will implement `src/sandbox/isolate.ts`. This module manages the lifecycle
    of the `isolated-vm` instance. It ensures that every tool runs in a fresh
    context with strict memory limits (128MB) to prevent resource exhaustion
    attacks.
  - '### Step 3: The Context Bridge'
  - >-
    I will implement `src/sandbox/bridge.ts`. This defines what capabilities are
    exposed to the guest script. We strictly control the `tgp` global object,
    preventing access to `process`, `fs` (real), or `net`.
  - '### Step 4: The Execution Runner'
  - >-
    I will implement `src/sandbox/execute.ts`. This is the high-level function
    that the Agent uses to run tools. It combines the `Sandbox` and the
    `Bridge`.
operations:
  - type: write
    path: package.json
    content: |
      <<<<<<< SEARCH
          "isomorphic-git": "^1.25.0",
          "memfs": "^4.6.0"
        },
      =======
          "isomorphic-git": "^1.25.0",
          "memfs": "^4.6.0",
          "isolated-vm": "^4.6.0",
          "esbuild": "^0.19.0"
        },
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: src/sandbox/isolate.ts
    content: |-
      import ivm from 'isolated-vm';
      import { transform } from 'esbuild';

      /**
       * Configuration for the V8 Sandbox.
       */
      export interface SandboxOptions {
        memoryLimitMb?: number; // Default 128MB
        timeoutMs?: number;     // Default 5000ms
      }

      export interface Sandbox {
        compileAndRun: (code: string, context: Record<string, any>) => Promise<any>;
        dispose: () => void;
      }

      /**
       * Creates a secure V8 Isolate.
       */
      export function createSandbox(opts: SandboxOptions = {}): Sandbox {
        const memoryLimit = opts.memoryLimitMb || 128;
        const timeout = opts.timeoutMs || 5000;

        // Create the heavy V8 Isolate (The Virtual Machine)
        const isolate = new ivm.Isolate({ memoryLimit });

        return {
          async compileAndRun(tsCode: string, context: Record<string, any>) {
            // 1. JIT Compile (TypeScript -> JavaScript)
            // We use esbuild for speed.
            const transformed = await transform(tsCode, {
              loader: 'ts',
              format: 'cjs', // CommonJS ensures simple execution in V8
              target: 'es2020',
            });

            const jsCode = transformed.code;

            // 2. Create a fresh Context for this execution
            const ivmContext = await isolate.createContext();

            try {
              // 3. Bridge the Global Scope (Host -> Guest)
              const jail = ivmContext.global;
              
              // Inject the 'tgp' global object which holds our bridge
              await jail.set('global', jail.derefInto()); // standard polyfill
              
              // We iterate over the context object and inject functions/values
              for (const [key, value] of Object.entries(context)) {
                  if (typeof value === 'function') {
                      // Bridge functions: Host runs the logic, Guest calls it
                      await jail.set(key, new ivm.Reference(value));
                  } else {
                      // Bridge values: Copy by value (JSON safe)
                      await jail.set(key, new ivm.ExternalCopy(value).copyInto());
                  }
              }

              // 4. Compile the Script inside the Isolate
              const script = await isolate.compileScript(jsCode);

              // 5. Execute
              const result = await script.run(ivmContext, { timeout });
              
              // 6. Return result (Unwrap from IVM)
              if (result && typeof result === 'object' && 'copy' in result) {
                  // If it's a reference, try to copy it out, otherwise return as is
                  return result.copy();
              }
              return result;

            } finally {
              // Cleanup the context to free memory immediately
              ivmContext.release();
            }
          },

          dispose() {
            if (!isolate.isDisposed) {
              isolate.dispose();
            }
          }
        };
      }
    patchStrategy: replace
  - type: write
    path: src/sandbox/bridge.ts
    content: |-
      import { Kernel } from '../kernel/core.js';

      /**
       * Creates the Bridge Object exposed to the Sandbox.
       * This maps secure Kernel methods to the Guest environment.
       * 
       * NOTE: When passing functions to isolated-vm, arguments and return values 
       * must be serializable or wrapped in References.
       */
      export function createSandboxBridge(kernel: Kernel) {
        const { vfs } = kernel;

        return {
          // --- Filesystem Bridge (Jailed) ---
          // The Guest sees these as async functions on the global scope or a 'tgp' object.
          
          // tgp_read_file('./data.txt')
          tgp_read_file: async (path: string) => {
            // VFS already enforces jail path traversal checks
            return vfs.readFile(path);
          },

          // tgp_write_file('./output.txt', 'content')
          tgp_write_file: async (path: string, content: string) => {
            return vfs.writeFile(path, content);
          },

          // tgp_list_files('./tools')
          tgp_list_files: async (dir: string) => {
            return vfs.listFiles(dir, false);
          },

          // --- Network Bridge (Allowed Only) ---
          // We can inject a restricted fetch here.
          tgp_fetch: async (url: string, init?: any) => {
            // Security: Parse URL and allow-list check could happen here
            const response = await fetch(url, init);
            const text = await response.text();
            return {
              status: response.status,
              text: () => text,
              json: () => JSON.parse(text),
            };
          },

          // --- Logger ---
          tgp_log: (...args: any[]) => {
            console.log('[TGP-TOOL]', ...args);
          }
        };
      }
    patchStrategy: replace
  - type: write
    path: src/sandbox/execute.ts
    content: >-
      import { Kernel } from '../kernel/core.js';

      import { createSandbox } from './isolate.js';

      import { createSandboxBridge } from './bridge.js';


      /**
       * Executes a tool script within a secure sandbox.
       * 
       * @param kernel The TGP Kernel instance
       * @param code The TypeScript source code of the tool
       * @param args The arguments object to pass to the tool (as 'args' global)
       */
      export async function executeTool(kernel: Kernel, code: string, args:
      Record<string, any> = {}): Promise<any> {
        const sandbox = createSandbox({
          memoryLimitMb: 128,
          timeoutMs: 5000 // 5s hard limit
        });

        try {
          const bridge = createSandboxBridge(kernel);

          // Context Injection:
          // 1. The 'args' object (Input)
          // 2. The Bridge functions (Capabilities)
          const context = {
            args,
            ...bridge
          };

          // We wrap the user code to ensure it can consume the 'args' and use the bridge.
          // The user code is expected to be a module or script. 
          // We wrap it in an IIFE to allow top-level execution flows if needed, 
          // but typically we expect a standard script execution.
          // 
          // We explicitly expose the bridge functions on the global scope by the isolate.ts logic.
          
          const result = await sandbox.compileAndRun(code, context);
          return result;

        } catch (error) {
          console.error(`[TGP] Tool Execution Failed:`, error);
          throw new Error(`Tool execution failed: ${error instanceof Error ? error.message : String(error)}`);
        } finally {
          sandbox.dispose();
        }
      }
    patchStrategy: replace
snapshot:
  src/sandbox/isolate.ts: null
  src/sandbox/bridge.ts: null
  src/sandbox/execute.ts: null
  package.json: |-
    {
      "name": "@tgp/core",
      "version": "0.0.1",
      "description": "The Tool Generation Protocol",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "type": "module",
      "scripts": {
        "build": "tsc",
        "test": "echo \"Error: no test specified\" && exit 1"
      },
      "keywords": [
        "ai",
        "agent",
        "protocol",
        "backend"
      ],
      "author": "",
      "license": "MIT",
      "dependencies": {
        "zod": "^3.22.4",
        "isomorphic-git": "^1.25.0",
        "memfs": "^4.6.0"
      },
      "devDependencies": {
        "@types/node": "^20.11.0",
        "typescript": "^5.3.3"
      }
    }
approved: true
linesAdded: 184
linesRemoved: 1
linesDifference: 185
gitCommittedAt: '2025-11-27T10:05:15.003Z'
status: committed
id: 6

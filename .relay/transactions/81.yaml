uuid: 4f12d8a1-5b7c-4e3a-9c2d-8f12d8a15b7c
projectId: tool-generation-protocol
createdAt: '2025-11-28T14:18:12.418Z'
gitCommitMsg: >-
  test: add docker-based npm compatibility test suite

  Introduces 'test/docker/npm-compat.test.ts' which builds the package, installs
  it in an 'oven/bun:1' container, and runs the E2E scenarios against the
  installed dependency. This ensures the published artifact is complete and
  functional.
promptSummary: >-
  Added a Docker-based test suite to verify the NPM package functionality in an
  isolated environment.
reasoning:
  - >-
    The objective is to create a robust, Docker-based test suite that verifies
    the `tool-generation-protocol` package as it would be used by a real
    consumer (via NPM installation). This ensures all exports, configuration
    loaders, and binaries work correctly when decoupled from the source tree.
  - '### Step 1: Docker Utilities'
  - >-
    We'll start by creating the infrastructure to build the package tarball and
    manage Docker containers.
  - '### Step 2: NPM Compatibility Test Suite'
  - >-
    Now we create the test suite that uses `oven/bun:1` to run our E2E tests
    against the packed tarball. This involves patching the test files inside the
    container to point to the installed package instead of the local source
    tree.
  - '### Final Step'
  - Generate the YAML summary.
operations:
  - type: write
    path: test/docker/utils.ts
    content: |-
      import { spawn, spawnSync, execSync } from 'node:child_process';
      import * as path from 'node:path';
      import * as fs from 'node:fs';

      /**
       * Creates an NPM tarball from the current project directory.
       * Ensures a fresh build is present before packing.
       * Returns the absolute path to the generated .tgz file.
       */
      export async function createTarball(cwd: string): Promise<string> {
        // Ensure we have a clean build. 'npm pack' relies on the presence of dist/ 
        // if 'dist' is in the 'files' list in package.json.
        try {
            execSync('npm run build', { cwd, stdio: 'inherit' });
        } catch (e) {
            throw new Error('Build failed before packing');
        }

        const res = spawnSync('npm', ['pack'], { cwd, encoding: 'utf-8' });
        
        if (res.error) throw res.error;
        if (res.status !== 0) throw new Error(`npm pack failed: ${res.stderr}`);
        
        // npm pack outputs the filename on stdout (e.g., tool-generation-protocol-0.0.1.tgz)
        const filename = res.stdout.trim().split('\n').pop()?.trim();
        if (!filename) throw new Error('Could not determine tarball filename from npm pack output');
        
        return path.resolve(cwd, filename);
      }

      /**
       * A simple wrapper around Docker CLI to manage a test container.
       */
      export class Container {
        id: string | null = null;

        constructor(public image: string) {}

        /**
         * Starts the container in detached mode with TTY to keep it alive.
         */
        async start(): Promise<void> {
          const res = spawnSync('docker', ['run', '-d', '--rm', '-t', this.image, 'bash'], { encoding: 'utf-8' });
          if (res.status !== 0) {
              throw new Error(`Failed to start container: ${res.stderr}`);
          }
          this.id = res.stdout.trim();
        }

        /**
         * Executes a command inside the container.
         */
        async exec(cmd: string[], opts: { cwd?: string, env?: Record<string, string> } = {}): Promise<{ stdout: string, stderr: string, exitCode: number }> {
          if (!this.id) throw new Error('Container not started');
          
          const args = ['exec'];
          if (opts.cwd) {
              args.push('-w', opts.cwd);
          }
          if (opts.env) {
              for (const [k, v] of Object.entries(opts.env)) {
                  args.push('-e', `${k}=${v}`);
              }
          }
          args.push(this.id);
          args.push(...cmd);

          return new Promise((resolve, reject) => {
              const proc = spawn('docker', args);
              let stdout = '';
              let stderr = '';

              proc.stdout.on('data', d => stdout += d.toString());
              proc.stderr.on('data', d => stderr += d.toString());

              proc.on('close', (code) => {
                  resolve({ stdout, stderr, exitCode: code ?? -1 });
              });
              
              proc.on('error', (err) => reject(err));
          });
        }

        /**
         * Copies a file or directory from the host to the container.
         */
        async cp(src: string, dest: string): Promise<void> {
            if (!this.id) throw new Error('Container not started');
            try {
                execSync(`docker cp "${src}" "${this.id}:${dest}"`);
            } catch (e: any) {
                throw new Error(`Failed to copy ${src} to ${dest}: ${e.message}`);
            }
        }

        /**
         * Stops the container (which auto-removes it due to --rm).
         */
        async stop(): Promise<void> {
          if (this.id) {
              try {
                  execSync(`docker stop -t 0 ${this.id}`, { stdio: 'ignore' });
              } catch {}
              this.id = null;
          }
        }
      }
    patchStrategy: replace
  - type: write
    path: test/docker/npm-compat.test.ts
    content: >-
      import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach
      } from 'bun:test';

      import * as path from 'node:path';

      import * as fs from 'node:fs/promises';

      import * as os from 'node:os';

      import { createTarball, Container } from './utils.js';


      // Define the root of the project

      const projectRoot = path.resolve(__dirname, '../../');


      // Modified utils.ts to be injected into the container

      // This ensures tests use the installed package
      'tool-generation-protocol' 

      // instead of trying to resolve local paths or dist/ folders.

      const CONTAINER_UTILS_TS = `

      import * as fs from 'node:fs/promises';

      import * as path from 'node:path';

      import * as os from 'node:os';

      import { spawn, execSync } from 'node:child_process';


      const tempDirs: string[] = [];


      export async function createTempDir(prefix: string = 'tgp-e2e-'):
      Promise<string> {
        const tmpDir = os.tmpdir();
        const dir = await fs.mkdtemp(path.join(tmpDir, prefix));
        tempDirs.push(dir);
        return dir;
      }


      export async function cleanupDir(dir: string): Promise<void> {
        await fs.rm(dir, { recursive: true, force: true }).catch(() => {});
      }


      export async function initBareRepo(dir: string): Promise<void> {
        await fs.mkdir(dir, { recursive: true });
        execSync(\`git init --bare\`, { cwd: dir, stdio: 'ignore' });
        const initDir = await createTempDir('tgp-init-');
        execSync(\`git init\`, { cwd: initDir, stdio: 'ignore' });
        await fs.writeFile(path.join(initDir, 'README.md'), '# Remote Root');
        execSync(\`git add .\`, { cwd: initDir, stdio: 'ignore' });
        execSync(\`git commit -m "Initial commit"\`, { cwd: initDir, stdio: 'ignore' });
        execSync(\`git remote add origin \${dir}\`, { cwd: initDir, stdio: 'ignore' });
        execSync(\`git push origin master:main\`, { cwd: initDir, stdio: 'ignore' });
        await cleanupDir(initDir);
        execSync(\`git symbolic-ref HEAD refs/heads/main\`, { cwd: dir, stdio: 'ignore' });
      }


      export async function createTgpConfig(workDir: string, remoteRepo: string,
      fileName: string = 'tgp.config.ts'): Promise<string> {
          const rootDir = path.join(workDir, '.tgp').split(path.sep).join('/');
          const remotePath = remoteRepo.split(path.sep).join('/');
          const allowedDir = workDir.split(path.sep).join('/');

          // OVERRIDE: Use the package name directly for imports
          const configContent = \`
      import { defineTGPConfig } from 'tool-generation-protocol';


      export default defineTGPConfig({
        rootDir: '\${rootDir}',
        git: {
          provider: 'local',
          repo: '\${remotePath}',
          branch: 'main',
          auth: { token: 'mock', user: 'test', email: 'test@example.com' }
        },
        fs: {
          allowedDirs: ['\${allowedDir}', '\${os.tmpdir().split(path.sep).join('/')}'],
          blockUpwardTraversal: false
        },
        allowedImports: ['zod', 'date-fns']
      });

      \`;
          const configPath = path.join(workDir, fileName);
          await fs.writeFile(configPath, configContent);
          return configPath;
      }


      export function runTgpCli(args: string[], cwd: string): Promise<{ stdout:
      string, stderr: string, code: number }> {
          return new Promise(async (resolve) => {
              // OVERRIDE: Use bunx tgp to execute the installed binary
              const proc = spawn('bunx', ['tgp', ...args], {
                  cwd,
                  env: { ...process.env, NODE_ENV: 'test' }
              });

              let stdout = '';
              let stderr = '';

              proc.stdout.on('data', d => stdout += d.toString());
              proc.stderr.on('data', d => stderr += d.toString());

              proc.on('close', (code) => {
                  resolve({ stdout, stderr, code: code ?? -1 });
              });
          });
      }


      process.on('exit', () => {
          tempDirs.forEach(d => {
              try { execSync(\`rm -rf \${d}\`); } catch {}
          });
      });

      `;


      describe('Docker: NPM Compatibility', () => {
        let tarballPath: string;
        let container: Container;
        
        // High timeout for Docker operations
        const TIMEOUT = 120000; 

        beforeAll(async () => {
          // 1. Build the Tarball from source
          console.log('[Docker] Building NPM Tarball...');
          tarballPath = await createTarball(projectRoot);
          console.log(`[Docker] Tarball created at: ${tarballPath}`);
        });

        beforeEach(async () => {
          // 2. Start a fresh container
          container = new Container('oven/bun:1');
          await container.start();
          console.log(`[Docker] Container started: ${container.id}`);
        });

        afterEach(async () => {
          if (container) await container.stop();
        });

        afterAll(async () => {
          // Cleanup the local tarball
          if (tarballPath) await fs.rm(tarballPath, { force: true });
        });

        it('installs and runs E2E scenarios correctly', async () => {
          // 3. Prepare Environment inside Container
          console.log('[Docker] Installing dependencies (git)...');
          await container.exec(['apt-get', 'update']);
          await container.exec(['apt-get', 'install', '-y', 'git']);
          
          // Configure Git (required for TGP tests)
          await container.exec(['git', 'config', '--global', 'user.email', 'test@example.com']);
          await container.exec(['git', 'config', '--global', 'user.name', 'Test User']);

          // 4. Setup Test Project
          await container.exec(['mkdir', '-p', '/app']);
          
          // Copy tarball
          console.log('[Docker] Copying artifacts...');
          await container.cp(tarballPath, '/app/tgp.tgz');
          
          // Copy tests (We only copy e2e as those are the consumer-facing tests)
          await container.exec(['mkdir', '-p', '/app/test']);
          await container.cp(path.join(projectRoot, 'test/e2e'), '/app/test/e2e');

          // Initialize Project & Install Package
          console.log('[Docker] Installing package...');
          await container.exec(['bun', 'init', '-y'], { cwd: '/app' });
          await container.exec(['bun', 'add', './tgp.tgz'], { cwd: '/app' });
          // Install dev dependencies needed for the tests themselves
          await container.exec(['bun', 'add', '-d', 'bun-types'], { cwd: '/app' });

          // 5. Patch Test Files
          console.log('[Docker] Patching tests to use installed package...');
          
          // Inject the Utils Override
          const utilsOverridePath = path.join(os.tmpdir(), 'utils_override.ts');
          await fs.writeFile(utilsOverridePath, CONTAINER_UTILS_TS);
          await container.cp(utilsOverridePath, '/app/test/e2e/utils.ts');
          
          // Patch scenarios.test.ts to import from 'tool-generation-protocol' instead of relative paths
          // Regex matches ../../src/... paths
          const sedCmd = `sed -i "s|\\.\\./\\.\\./src/[a-zA-Z0-9/._-]*|tool-generation-protocol|g" /app/test/e2e/scenarios.test.ts`;
          await container.exec(['bash', '-c', sedCmd]);

          // 6. Run Tests
          console.log('[Docker] Running Tests...');
          const res = await container.exec(['bun', 'test', 'test/e2e/scenarios.test.ts'], { cwd: '/app' });
          
          if (res.exitCode !== 0) {
              console.error('STDOUT:', res.stdout);
              console.error('STDERR:', res.stderr);
          }

          expect(res.exitCode).toBe(0);
          expect(res.stdout).toContain('passed');
        }, TIMEOUT);
      });
    patchStrategy: replace
snapshot:
  test/docker/utils.ts: null
  test/docker/npm-compat.test.ts: null
approved: true
linesAdded: 292
linesRemoved: 0
linesDifference: 292
gitCommittedAt: '2025-11-28T14:30:12.513Z'
status: committed
id: 81

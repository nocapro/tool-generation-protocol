uuid: d8e5e60d-777e-4b62-af13-3932cf4319a9
projectId: tool-generation-protocol
createdAt: '2025-11-28T01:33:09.592Z'
gitCommitMsg: >-
  refactor(core): Harden TGP kernel for production readiness

  This commit implements a series of changes to make the TGP core more robust,
  secure, and developer-friendly.

  - **Decouple DB Backend**: Removes the database configuration schema
  (`DBConfigSchema`) and the `createDBBackend` factory. The kernel now expects a
  `DBBackend` implementation to be injected by the host application, defaulting
  to a `NoOpDB` if not provided. This enforces a clear separation of concerns.

  - **Streamline Public API**: Deletes the redundant `createTGP` and standalone
  `getSystemPrompt` factory functions. The `TGP` class is now the single,
  authoritative entry point for interacting with the kernel.

  - **Harden Sandbox Fetch**: Implements a strict URL whitelist for the
  sandbox's `fetch` bridge. The allowed URL prefixes must be defined in
  `tgp.config.ts` via the new `allowedFetchUrls` property. Network access is
  disabled by default if this is not configured. The fetch proxy is also updated
  to correctly handle async `json()` and `text()` methods.

  - **Improve DX**: Adds a `dev` script to `package.json` using `tsx` to enable
  running the CLI directly from TypeScript source, improving the development
  workflow. A stray duplicate `Kernel` interface file has been removed.
promptSummary: >-
  The user wants to harden the TGP core codebase to be production-ready. This
  involves removing stubbed/unimplemented features like the database factory,
  streamlining the public API, cleaning up stray files, and securing the sandbox
  `fetch` implementation.
reasoning:
  - This refactor will harden the TGP core for production use.
  - >-
    First, I will decouple the database backend. The TGP kernel shouldn't manage
    database connections; that is the responsibility of the host application. I
    will remove all database configuration from TGP's types and config
    templates, and modify the kernel to accept an injected `DBBackend`. If none
    is provided, it will default to a silent, no-op backend suitable for testing
    or environments without a database.
  - >-
    Next, I'll streamline the public API and developer experience. The redundant
    `createTGP` factory function will be removed, establishing the `TGP` class
    as the single, clear entry point. I'll also delete a stray, duplicated
    `Kernel` interface file and add a `dev` script to `package.json` to simplify
    running the CLI from source during development.
  - >-
    Finally, I will harden the sandbox. The current `fetch` bridge is a security
    placeholder. I will implement a robust URL whitelist, configured in
    `tgp.config.ts`, to ensure tools can only make network requests to approved
    endpoints. The implementation will also be corrected to properly proxy the
    `Response` object's methods, like `.json()` and `.text()`, instead of
    unsafely buffering the entire response.
  - >-
    These changes will result in a leaner, more secure, and more professional
    TGP core.
  - '---'
  - >-
    I will first remove the database configuration from the core types, as the
    host application will now be responsible for providing a database backend.
    I'll also add the new `allowedFetchUrls` configuration for the sandbox
    networking bridge.
  - >-
    With the DB configuration removed, I'll simplify the database backend
    factory. It will no longer attempt to create backends from config, and will
    only provide the no-op implementation for testing or when a backend isn't
    injected.
  - >-
    Now, I'll update the kernel's factory to use the `createNoOpDB` as a
    fallback if a database backend is not explicitly provided during
    initialization.
  - >-
    I will update the configuration template generated by the `init` command to
    remove the obsolete `db` section and add the new `allowedFetchUrls` property
    as an example.
  - >-
    Similarly, I'll update the `README.md` to reflect the change in the
    configuration file structure.
  - >-
    To streamline the public API, I will remove the legacy factory functions
    `createTGP` and `getSystemPrompt` from the main `tgp.ts` file.
  - >-
    Next, I'll delete the stray file containing a duplicate `Kernel` interface
    definition.
  - >-
    To improve the developer experience, I'll add a `dev` script to
    `package.json` for running the CLI directly from TypeScript source, and add
    `tsx` as a development dependency.
  - >-
    Finally, I'll harden the sandbox bridge by implementing the URL whitelist
    check for the `fetch` command and ensuring the returned response object is a
    secure and correct proxy.
operations:
  - type: write
    path: src/types.ts
    content: >
      --- src/types.ts

      +++ src/types.ts

      @@ -8,14 +8,6 @@
         writeStrategy: z.enum(['direct', 'pr']).default('direct'),
       });
       
      -// --- Database Configuration Schema ---

      -export const DBConfigSchema = z.object({

      -  dialect: z.enum(['postgres', 'mysql', 'sqlite', 'libsql']),

      -  ddlSource: z.string().optional().describe("Command to generate DDL,
      e.g., 'drizzle-kit generate'"),

      -});

      -
       // --- Filesystem Jail Schema ---
       export const FSConfigSchema = z.object({
         allowedDirs: z.array(z.string()).default(['./tmp']),
      @@ ... @@
       // --- Main TGP Configuration Schema ---
       export const TGPConfigSchema = z.object({
         rootDir: z.string().default('./.tgp'),
      -  db: DBConfigSchema.optional(),
         git: GitConfigSchema,
         fs: FSConfigSchema.default({}),
         allowedImports: z.array(z.string()).default(['@tgp/std', 'zod', 'date-fns']),
      +  allowedFetchUrls: z.array(z.string()).optional().describe('Whitelist of
      URL prefixes the sandbox fetch can access.'),
       });
       
       // --- Inferred Static Types ---
       // We export these so the rest of the app relies on the Zod inference, 
       // ensuring types and validation never drift apart.
       export type GitConfig = z.infer<typeof GitConfigSchema>;
      -export type DBConfig = z.infer<typeof DBConfigSchema>;
       export type FSConfig = z.infer<typeof FSConfigSchema>;
       export type TGPConfig = z.infer<typeof TGPConfigSchema>;
       
    patchStrategy: standard-diff
  - type: write
    path: src/kernel/db.ts
    content: |-
      /* eslint-disable no-console */
      import { DBBackend } from '../types.js';

      /**
       * A No-Op Database Backend used when no DB is configured.
       * It logs operations to the console and is useful for testing or running without a database.
       */
      export function createNoOpDB(): DBBackend {
        return {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          async query(sql: string, params: any[] = []) {
            console.log(`[TGP-DB] Query: ${sql}`, params);
            return [];
          },

          async transaction<T>(fn: (trx: DBBackend) => Promise<T>): Promise<T> {
            console.log(`[TGP-DB] Begin Transaction`);
            try {
              // In a real DB, we would start a trx here.
              // We pass 'this' as the transactional client (NoOp doesn't distinguish)
              const result = await fn(this);
              console.log(`[TGP-DB] Commit Transaction`);
              return result;
            } catch (err) {
              console.log(`[TGP-DB] Rollback Transaction`);
              throw err;
            }
          }
        };
      }
    patchStrategy: replace
  - type: write
    path: src/kernel/core.ts
    content: |
      --- src/kernel/core.ts
      +++ src/kernel/core.ts
      @@ -2,7 +2,7 @@
       import { TGPConfig, Logger, DBBackend } from '../types.js';
       import { VFSAdapter } from '../vfs/types.js';
       import { createGitBackend, GitBackend, GitDependencies } from './git.js';
      -import { createDBBackend } from './db.js';
      +import { createNoOpDB } from './db.js';
       import { createRegistry, Registry } from './registry.js';
       
       // We inject the platform-specific environment dependencies here.
      @@ ... @@
       export function createKernel(opts: KernelOptions): Kernel {
         const { config, vfs, env } = opts;
         const logger = opts.logger ?? defaultLogger;
         
         const git = createGitBackend(env, config, logger);
      -  const db = opts.db ?? createDBBackend(config); 
      +  const db = opts.db ?? createNoOpDB(); 
         const registry = createRegistry(vfs);
       
         let isBooted = false;
    patchStrategy: standard-diff
  - type: write
    path: src/cli/init.ts
    content: >
      --- src/cli/init.ts

      +++ src/cli/init.ts

      @@ -42,14 +42,8 @@
         // The Root of the Agent's filesystem (Ephemeral in serverless)
         rootDir: './.tgp',
       
      -  // 1. DATA: How the Agent sees your DB

      -  db: {

      -    dialect: 'postgres',

      -    ddlSource: 'drizzle-kit generate --print',

      -  },

      -

      -  // 2. BACKEND (GitOps)

      +  // 1. BACKEND (GitOps)
         // Essential for Serverless/Ephemeral environments.
         // The Agent pulls state from here and pushes new tools here.
         git: {
      @@ ... @@
           writeStrategy: process.env.NODE_ENV === 'production' ? 'pr' : 'direct'
         },
       
      -  // 3. FILESYSTEM JAIL

      +  // 2. FILESYSTEM JAIL
         fs: {
           allowedDirs: ['./public/exports', './tmp'],
           blockUpwardTraversal: true
         },
       
      -  // 4. RUNTIME

      -  allowedImports: ['@tgp/std', 'zod', 'date-fns']

      +  // 3. RUNTIME

      +  allowedImports: ['@tgp/std', 'zod', 'date-fns'],

      +

      +  // 4. NETWORKING

      +  // Whitelist of URL prefixes the sandbox fetch can access.

      +  // e.g. allowedFetchUrls: ['https://api.stripe.com',
      'https://api.github.com']

      +  allowedFetchUrls: []
       });
       `;
    patchStrategy: standard-diff
  - type: write
    path: README.md
    content: |-
      --- README.md
      +++ README.md
      @@ -201,14 +201,8 @@
         // The Root of the Agent's filesystem (Ephemeral in serverless)
         rootDir: './.tgp',
         // NOTE: The 'db' and 'fs' sections below are METADATA for the Agent.
         // The actual database and filesystem permissions must be injected at runtime.
       
      -  // 1. DATA: How the Agent sees your DB
      -  db: {
      -    dialect: 'postgres',
      -    ddlSource: 'drizzle-kit generate --print',
      -  },
      -
      -  // 2. BACKEND (GitOps)
      +  // 1. BACKEND (GitOps)
         // Essential for Serverless/Ephemeral environments.
         // The Agent pulls state from here and pushes new tools here.
         git: {
      @@ ... @@
           // Strategy: 'direct' (push) or 'pr' (pull request)
           writeStrategy: process.env.NODE_ENV === 'production' ? 'pr' : 'direct'
         },
       
      -  // 3. FILESYSTEM JAIL
      +  // 2. FILESYSTEM JAIL
         fs: {
           allowedDirs: ['./public/exports', './tmp'],
           blockUpwardTraversal: true
         },
       
      -  // 4. RUNTIME
      -  allowedImports: ['@tgp/std', 'zod', 'date-fns']
      +  // 3. RUNTIME
      +  allowedImports: ['@tgp/std', 'zod', 'date-fns'],
      +
      +  // 4. NETWORKING
      +  // Whitelist of URL prefixes the sandbox fetch can access.
      +  allowedFetchUrls: ['https://api.stripe.com']
       });
       
    patchStrategy: standard-diff
  - type: write
    path: src/tgp.ts
    content: |
      --- src/tgp.ts
      +++ src/tgp.ts
      @@ -165,22 +165,3 @@
       `;
         }
       }
      -
      -/**
      - * Legacy Factory to create a TGP Kernel (Backward Compatibility).
      - */
      -export async function createTGP(opts: TGPOptions = {}): Promise<Kernel> {
      -  const tgp = new TGP(opts);
      -  await tgp.boot();
      -  return tgp;
      -}
      -
      -/**
      - * Helper to get the system prompt (Backward Compatibility).
      - */
      -export function getSystemPrompt(): string {
      -  return new TGP().getSystemPrompt();
      -}
    patchStrategy: standard-diff
  - type: delete
    path: export interface Kernel {
  - type: write
    path: package.json
    content: |
      <<<<<<< SEARCH
        "scripts": {
          "build": "tsc",
          "lint": "eslint src/**/*.ts",
          "lint:fix": "eslint src/**/*.ts --fix",
          "test": "echo \"Error: no test specified\" && exit 1",
          "tgp": "node bin/tgp.js"
        },
      =======
        "scripts": {
          "build": "tsc",
          "dev": "tsx src/cli/index.ts",
          "lint": "eslint src/**/*.ts",
          "lint:fix": "eslint src/**/*.ts --fix",
          "test": "echo \"Error: no test specified\" && exit 1",
          "tgp": "node bin/tgp.js"
        },
      >>>>>>> REPLACE
      <<<<<<< SEARCH
        "devDependencies": {
          "@types/node": "^20.19.25",
          "@typescript-eslint/eslint-plugin": "^8.48.0",
          "@typescript-eslint/parser": "^8.48.0",
          "eslint": "^9.39.1",
          "typescript": "^5.9.3"
        }
      =======
        "devDependencies": {
          "@types/node": "^20.19.25",
          "@typescript-eslint/eslint-plugin": "^8.48.0",
          "@typescript-eslint/parser": "^8.48.0",
          "eslint": "^9.39.1",
          "tsx": "^4.16.2",
          "typescript": "^5.9.3"
        }
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: src/sandbox/bridge.ts
    content: >
      --- src/sandbox/bridge.ts

      +++ src/sandbox/bridge.ts

      @@ -1,9 +1,13 @@
       /* eslint-disable no-console */
       import { Kernel } from '../kernel/core.js';
       import * as path from 'path';
      +import { TGPConfig } from '../types.js';
       
       export interface SandboxBridgeOptions {
      -  kernel: Pick<Kernel, 'vfs' | 'config'>;

      +  kernel: {

      +    vfs: Kernel['vfs'];

      +    config: TGPConfig;

      +  };
         onLog?: (message: string) => void;
       }
       
      @@ ... @@
        */
       export function createSandboxBridge({ kernel, onLog }: SandboxBridgeOptions) {
         const { vfs, config } = kernel;
      -  const { allowedDirs } = config.fs;

      +  const { allowedDirs } = config.fs;

      +  const { allowedFetchUrls } = config;
       
         const isAllowedWrite = (target: string): boolean => {
           // Normalize target to ensure clean comparison (remove leading ./, etc)
      @@ ... @@
             },
       
             // --- Network Bridge (Allowed Only) ---
             // eslint-disable-next-line @typescript-eslint/no-explicit-any
             fetch: async (url: string, init?: any) => {
      -        // Security: Parse URL and allow-list check could happen here

      +        // Security: Enforce URL allow-list

      +        if (!allowedFetchUrls || allowedFetchUrls.length === 0) {

      +          throw new Error(`Security Violation: Network access is
      disabled. No URLs are whitelisted in tgp.config.ts.`);

      +        }

      +        const isAllowed = allowedFetchUrls.some(prefix =>
      url.startsWith(prefix));

      +        if (!isAllowed) {

      +          throw new Error(`Security Violation: URL "${url}" is not in the
      allowed list.`);

      +        }

      +
               const response = await fetch(url, init);
      -        const text = await response.text();

      +        

      +        // Return a serializable, safe subset of the Response object.

      +        // The methods must be wrapped to be transferred correctly.
               return {
                 status: response.status,
      -          text: () => text,

      -          json: () => JSON.parse(text),

      +          statusText: response.statusText,

      +          headers: Object.fromEntries(response.headers.entries()),

      +          text: () => response.text(),

      +          json: () => response.json(),
               };
             },
       
    patchStrategy: standard-diff
snapshot:
  src/types.ts: |-
    import { z } from 'zod';

    // --- Git Configuration Schema ---
    export const GitConfigSchema = z.object({
      provider: z.enum(['github', 'gitlab', 'bitbucket']),
      repo: z.string().min(1, "Repository name is required"),
      branch: z.string().default('main'),
      apiBaseUrl: z.string().url().default('https://api.github.com'),
      auth: z.object({
        token: z.string().min(1, "Git auth token is required"),
        user: z.string().default('tgp-bot[bot]'),
        email: z.string().email().default('tgp-bot@users.noreply.github.com'),
      }),
      writeStrategy: z.enum(['direct', 'pr']).default('direct'),
    });

    // --- Database Configuration Schema ---
    export const DBConfigSchema = z.object({
      dialect: z.enum(['postgres', 'mysql', 'sqlite', 'libsql']),
      ddlSource: z.string().optional().describe("Command to generate DDL, e.g., 'drizzle-kit generate'"),
    });

    // --- Filesystem Jail Schema ---
    export const FSConfigSchema = z.object({
      allowedDirs: z.array(z.string()).default(['./tmp']),
      blockUpwardTraversal: z.boolean().default(true),
    });

    // --- Main TGP Configuration Schema ---
    export const TGPConfigSchema = z.object({
      rootDir: z.string().default('./.tgp'),
      db: DBConfigSchema.optional(),
      git: GitConfigSchema,
      fs: FSConfigSchema.default({}),
      allowedImports: z.array(z.string()).default(['@tgp/std', 'zod', 'date-fns']),
    });

    // --- Inferred Static Types ---
    // We export these so the rest of the app relies on the Zod inference, 
    // ensuring types and validation never drift apart.
    export type GitConfig = z.infer<typeof GitConfigSchema>;
    export type DBConfig = z.infer<typeof DBConfigSchema>;
    export type FSConfig = z.infer<typeof FSConfigSchema>;
    export type TGPConfig = z.infer<typeof TGPConfigSchema>;

    /**
     * Defines the structure for a tool file persisted in the VFS.
     * This is what resides in ./.tgp/tools/
     */
    export const ToolSchema = z.object({
      name: z.string(),
      description: z.string(),
      parameters: z.record(z.unknown()), // JsonSchema
      code: z.string(), // The raw TypeScript source
    });

    export type ToolDefinition = z.infer<typeof ToolSchema>;

    export interface ToolMetadata {
      name: string;
      description: string;
      path: string;
    }

    export interface RegistryState {
      tools: Record<string, ToolMetadata>;
    }

    export interface Logger {
      debug(message: string, ...args: any[]): void;
      info(message: string, ...args: any[]): void;
      warn(message: string, ...args: any[]): void;
      error(message: string, ...args: any[]): void;
    }

    /**
     * The Database Kernel Interface.
     *
     * TGP guarantees that all tool executions happen within a transaction.
     * If the tool throws, the transaction is rolled back.
     * This interface must be implemented by the host application and injected into the TGP Kernel.
     */
    export interface DBBackend {
      /**
       * Executes a raw SQL query.
       * @param sql The SQL query string.
       * @param params Parameter substitutions.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      query(sql: string, params?: any[]): Promise<any[]>;

      /**
       * Wraps a function in a database transaction.
       * @param fn The function to execute. It receives a transactional DB instance.
       */
      transaction<T>(fn: (trx: DBBackend) => Promise<T>): Promise<T>;
    }
  src/kernel/db.ts: |-
    /* eslint-disable no-console */
    import { TGPConfig, DBBackend } from '../types.js';

    /**
     * Factory to create the Database Backend based on configuration.
     * Loads the appropriate driver or falls back to NoOp.
     */
    export function createDBBackend(config: TGPConfig): DBBackend {
      const dbConfig = config.db;

      if (dbConfig) {
        // In a real implementation, we would perform a dynamic import here based on the dialect.
        // e.g. if (dbConfig.dialect === 'postgres') return new PostgresBackend(dbConfig);
        
        if (dbConfig.dialect === 'postgres' || dbConfig.dialect === 'mysql' || dbConfig.dialect === 'sqlite' || dbConfig.dialect === 'libsql') {
           console.warn(`[TGP-DB] Dialect '${dbConfig.dialect}' configured. NoOp driver active (Drivers not bundled in Core).`);
        } else {
          throw new Error(`[TGP-DB] Unsupported dialect: ${dbConfig.dialect}`);
        }
      }

      return createNoOpDB();
    }

    /**
     * A No-Op Database Backend used when no DB is configured.
     * It logs operations to the console to verify behavior.
     */
    export function createNoOpDB(): DBBackend {
      return {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        async query(sql: string, params: any[] = []) {
          console.log(`[TGP-DB] Query: ${sql}`, params);
          return [];
        },

        async transaction<T>(fn: (trx: DBBackend) => Promise<T>): Promise<T> {
          console.log(`[TGP-DB] Begin Transaction`);
          try {
            // In a real DB, we would start a trx here.
            // We pass 'this' as the transactional client (NoOp doesn't distinguish)
            const result = await fn(this);
            console.log(`[TGP-DB] Commit Transaction`);
            return result;
          } catch (err) {
            console.log(`[TGP-DB] Rollback Transaction`);
            throw err;
          }
        }
      };
    }
  src/kernel/core.ts: |-
    /* eslint-disable no-console */
    import { TGPConfig, Logger, DBBackend } from '../types.js';
    import { VFSAdapter } from '../vfs/types.js';
    import { createGitBackend, GitBackend, GitDependencies } from './git.js';
    import { createDBBackend } from './db.js';
    import { createRegistry, Registry } from './registry.js';

    // We inject the platform-specific environment dependencies here.
    // This allows the Kernel to run in Node, Edge, or Browser environments.
    export interface KernelEnvironment extends GitDependencies {
      // We can extend this if Kernel needs more platform specific components later
    }

    export interface KernelOptions {
      config: TGPConfig;
      vfs: VFSAdapter; 
      env: KernelEnvironment;
      logger?: Logger;
      db?: DBBackend;
    }

    export interface Kernel {
      boot(): Promise<void>;
      shutdown(): Promise<void>;
      config: TGPConfig;
      vfs: VFSAdapter;
      git: GitBackend;
      db: DBBackend;
      registry: Registry;
      logger: Logger;
    }

    const defaultLogger: Logger = {
      debug: (msg, ...args) => console.debug(`[TGP] ${msg}`, ...args),
      info: (msg, ...args) => console.log(`[TGP] ${msg}`, ...args),
      warn: (msg, ...args) => console.warn(`[TGP] ${msg}`, ...args),
      error: (msg, ...args) => console.error(`[TGP] ${msg}`, ...args),
    };

    /**
     * Factory to create a TGP Kernel.
     * This wires up the configuration, the filesystem, and the git backend.
     */
    export function createKernel(opts: KernelOptions): Kernel {
      const { config, vfs, env } = opts;
      const logger = opts.logger ?? defaultLogger;
      
      const git = createGitBackend(env, config, logger);
      const db = opts.db ?? createDBBackend(config); 
      const registry = createRegistry(vfs);

      let isBooted = false;

      return {
        config,
        vfs,
        git,
        db,
        registry,
        logger,

        async boot() {
          if (isBooted) return;
          logger.info(`Kernel booting...`);
          
          try {
            // Hydrate the filesystem from Git
            await git.hydrate().catch(err => {
              logger.error(`Git hydration failed.`, err);
              throw err;
            });
            
            // Hydrate registry from meta.json
            await registry.hydrate().catch(err => logger.warn(`Registry hydration warning:`, err));
            
            isBooted = true;
            logger.info(`Kernel ready.`);
          } catch (error) {
            logger.error(`Boot failed:`, error);
            throw error;
          }
        },

        async shutdown() {
          logger.info(`Kernel shutting down...`);
          // Cleanup tasks (close db connections, etc) can go here
          isBooted = false;
        }
      };
    }
  src/cli/init.ts: |-
    /* eslint-disable no-console */
    import * as fs from 'fs/promises';
    import * as path from 'path';

    export async function initCommand() {
      const cwd = process.cwd();
      console.log(`[TGP] Initializing in ${cwd}...`);

      const configPath = path.join(cwd, 'tgp.config.ts');
      const gitIgnorePath = path.join(cwd, '.gitignore');
      const tgpDir = path.join(cwd, '.tgp');
      const toolsDir = path.join(tgpDir, 'tools');
      const binDir = path.join(tgpDir, 'bin');
      const metaPath = path.join(tgpDir, 'meta.json');

      // 1. Create tgp.config.ts
      if (await exists(configPath)) {
        console.log(`[TGP] tgp.config.ts already exists. Skipping.`);
      } else {
        await fs.writeFile(configPath, CONFIG_TEMPLATE.trim());
        console.log(`[TGP] Created tgp.config.ts`);
      }

      // 2. Update .gitignore
      if (await exists(gitIgnorePath)) {
        const content = await fs.readFile(gitIgnorePath, 'utf-8');
        if (!content.includes('.tgp')) {
          await fs.appendFile(gitIgnorePath, '\n# TGP\n.tgp\n');
          console.log(`[TGP] Added .tgp to .gitignore`);
        }
      } else {
        await fs.writeFile(gitIgnorePath, '# TGP\n.tgp\n');
        console.log(`[TGP] Created .gitignore`);
      }

      // 3. Create .tgp directory (just to be nice)
      await fs.mkdir(tgpDir, { recursive: true });

      // 4. Scaffold Tools directory
      await fs.mkdir(toolsDir, { recursive: true });
      await fs.mkdir(binDir, { recursive: true });
      console.log(`[TGP] Created .tgp/tools and .tgp/bin directories`);

      // 5. Initialize Registry (meta.json)
      if (!await exists(metaPath)) {
        await fs.writeFile(metaPath, JSON.stringify({ tools: {} }, null, 2));
        console.log(`[TGP] Created .tgp/meta.json`);
      }

      console.log(`[TGP] Initialization complete. Run 'npx tgp' to start hacking.`);
    }

    async function exists(p: string) {
      try {
        await fs.access(p);
        return true;
      } catch {
        return false;
      }
    }

    const CONFIG_TEMPLATE = `
    import { defineTGPConfig } from '@tgp/core';

    export default defineTGPConfig({
      // The Root of the Agent's filesystem (Ephemeral in serverless)
      rootDir: './.tgp',

      // 1. DATA: How the Agent sees your DB
      db: {
        dialect: 'postgres',
        ddlSource: 'drizzle-kit generate --print',
      },

      // 2. BACKEND (GitOps)
      // Essential for Serverless/Ephemeral environments.
      // The Agent pulls state from here and pushes new tools here.
      git: {
        provider: 'github', // or 'gitlab', 'bitbucket'
        repo: 'my-org/tgp-tools',
        branch: 'main',
        auth: {
          // Why not in config? Because we read from ENV for security.
          token: process.env.TGP_GITHUB_TOKEN,
          user: 'tgp-bot[bot]',
          email: 'tgp-bot@users.noreply.github.com'
        },
        // Strategy: 'direct' (push) or 'pr' (pull request)
        writeStrategy: process.env.NODE_ENV === 'production' ? 'pr' : 'direct'
      },

      // 3. FILESYSTEM JAIL
      fs: {
        allowedDirs: ['./public/exports', './tmp'],
        blockUpwardTraversal: true
      },

      // 4. RUNTIME
      allowedImports: ['@tgp/std', 'zod', 'date-fns']
    });
    `;
  README.md: >
    # Tool Generation Protocol (TGP)


    > **The Self-Assembling Backend.**

    > **MCP is dead.** Stop streaming context. Start compiling tools.


    # 1. Manifesto


    **The Problem:** You spend 80% of your time writing "glue code"—RPCs, CRUD
    wrappers, and slightly different "Export to CSV" endpoints.

    **The Trap (MCP):** Model Context Protocol (MCP) is just better glue. It
    requires you to pre-build tools. If you didn't write the endpoint, the Agent
    fails.

    **The Solution (TGP):** Give the Agent a compiler.


    TGP is a **JIT Runtime for Business Logic**. The Agent forges its own tools,
    validates them, and persists them to Git. It builds a personalized standard
    library for your application.


    *   **MCP**: "I can't do that. I don't have a tool."

    *   **TGP**: "I wrote a tool. It's running."


    ## 1.1 Use Cases (The Long Tail)


    99% of features are never built because they are too specific. TGP solves
    the "I wish the app could do X" problem.


    *   **Reporting**: "List users who downgraded in June, pipe-delimited." ->
    Forges `tools/reports/downgrade.ts`. Time: 4s.

    *   **Cleanup**: "Fix typo in 'Ohiio' for active users." -> Forges
    `tools/maintenance/fix_typo.ts`. Atomic SQL update.

    *   **Logic**: "Calculate dimensional weight `(L*W*H)/139`." -> Forges
    `tools/shipping/dim_weight.ts`. Deterministic V8 execution.


    ## 1.2 Anti-Patterns


    TGP is a **JIT Compiler**, not a Daemon.

    *   **Not a Server**: No `express.listen()`. Tools are ephemeral
    (Lambda-style).

    *   **Not a Browser**: No DOM. No Puppeteer.

    *   **Not an ORM**: No object mutation. Use raw, atomic SQL.


    # 2. Architecture (The Stack)


    TGP drops into your existing Node/Next.js/Nest apps. It is **just
    TypeScript**.


    ## 2.1 The Developer View


    The agent views `./.tgp` as its root directory. This is a standard Git
    repository.


    ```bash

    ./.tgp/

    ├── .git/                  # MEMORY: Version history of TOOL SOURCE CODE.

    ├── bin/                   # KERNEL: The compiled 'tgp' binary.

    ├── tools/                 # USER SPACE: Generated capabilities.

    │   ├── analytics/         # e.g., "churn-prediction.ts"

    │   └── reports/           # e.g., "revenue-csv.ts"

    └── meta.json              # REGISTRY: Fast lookup index.

    ```


    ## 2.2 GitOps & Serverless Harmony


    **Is TGP Serverless Friendly?** Yes.


    In a Serverless environment (Cloudflare Workers, AWS Lambda, Vercel), the
    runtime filesystem is ephemeral. TGP handles this by treating **Git as the
    Backend**.


    1.  **Hydration**: On boot, TGP checks if the local cache matches the remote
    `HEAD`. If not, it pulls the latest tools from GitHub/GitLab.

    2.  **Execution**: Tools run in the local V8 Isolate (milliseconds).

    3.  **Persistence**: When an Agent forges a new tool, it commits and pushes
    to the remote repository.

    4.  **Concurrency**: TGP uses standard Git locking to handle concurrent
    writes from multiple agents.


    *Configuring GitHub credentials enables the "Infinite Memory" feature.*


    ## 2.3 The VFS (Virtual Filesystem)


    TGP enforces a strict separation between **The Editor (Host)** and **The
    Runtime (Sandbox)**.


    1.  **The Editor (Agent Context)**: The Agent accesses `./.tgp` directly via
    the Kernel Tools. It works just like a human dev using VS Code.

    2.  **The Runtime (Sandbox Context)**: When code *executes*, it runs inside
    the V8 Isolate with a restricted VFS:
        *   **`/lib`**: Read-Only mount of Host's `./.tgp/tools`.
        *   **`/tmp`**: Read-Write ephemeral scratchpad (wiped on exit).

    ## 2.4 The Kernel Tools (Agent Capabilities)


    The Agent is provided with a specific set of primitives to interact with the
    environment. It does not have generic shell access.


    | Tool | Signature | Description |

    | :--- | :--- | :--- |

    | **`list_files`** | `(dir: string) => string[]` | Recursively list
    available tools or definitions. |

    | **`read_file`** | `(path: string) => string` | Read the content of an
    existing tool or schema. |

    | **`write_file`** | `(path: string, content: string) => void` | Create a
    new tool or overwrite a draft. |

    | **`patch_file`** | `(path: string, search: string, replace: string) =>
    void` | Surgical search-and-replace for refactoring. |

    | **`check_tool`** | `(path: string) => { valid: boolean, errors: string[]
    }` | Run the JIT compiler and linter. |

    | **`exec_tool`** | `(path: string, args: object) => any` | Execute a tool
    inside the secure Sandbox. |


    ---


    # 3. The Protocol


    This is the algorithm the Agent must follow. It is the "software" running on
    the Agent's "CPU".


    ## 3.1 The Prime Directive: "Reuse or Forge"


    The Agent is forbidden from executing one-off scripts for repetitive tasks.


    1.  **Lookup**: Query registry. If a tool exists (Score > 0.85), **Reuse**.

    2.  **Forge**: If no tool exists, **Create**.

    3.  **Persist**: Commit to Git.


    ## 3.2 The 8 Standards of Code Quality


    To ensure the ecosystem remains clean, the Agent must adhere to strict code
    quality guidelines. The Linter/Reviewer will reject tools that violate these
    principles.


    1.  **Abstract**: Logic must be separated from specific data instances.
        *   *Bad*: `const tax = 0.05`
        *   *Good*: `const tax = args.taxRate`
    2.  **Composable**: Functions should do one thing and return a result usable
    by other functions.

    3.  **HOFs (Higher Order Functions)**: Use map/reduce/filter patterns rather
    than imperative loops where possible.

    4.  **Stateless**: Tools must not rely on variables outside their scope or
    previous executions.

    5.  **Reusable**: The code should be generic enough to serve multiple use
    cases.

    6.  **General by Params**: Behavior is controlled by arguments, not
    hardcoded strings.

    7.  **No Hardcoded Values**: No magic numbers, no specific IDs, no emails in
    source code.

    8.  **Orchestrator Capable**: Tools should be able to import and invoke
    other TGP tools (via the `require` bridge).


    ## 3.3 The Feedback Loop (Self-Healing)


    If a tool fails during execution:

    1.  **Capture**: Agent reads STDERR.

    2.  **Diagnose**: Agent identifies the logic error or schema mismatch.

    3.  **Patch**: Agent uses `patch_file` to fix the code in place.

    4.  **Verify**: Agent runs `check_tool`.


    ---


    # 4. Security (The Sandbox)


    **TL;DR:**

    1.  **Zero-Trust**: Tools run in a stripped V8 context. No `process`, no
    `fs`, no `eval`.

    2.  **Resource Caps**: 64MB RAM, 50ms CPU time. Infinite loops die
    instantly.

    3.  **Transaction Safety**: All DB writes run inside a transaction. If the
    tool throws, the DB rolls back.


    ## 4.1 The Great Wall (isolated-vm)

    TGP uses `isolated-vm` to create a boundary between the Host (Agent) and the
    Guest (Tool).

    *   **Memory**: Separate Heaps.

    *   **Syscalls**: Bridged via specific `tgp` global object.

    *   **Network**: Blocked by default. Allowed only via whitelisted `fetch`
    bridge.


    ---


    # 5. The Ecosystem (Join the Hive)


    We are building the **`libc` of the AI Age**.


    ## 5.1 The Logic/State Split

    In TGP, **Tools are Stateless**.

    *   **Logic (Public)**: The TypeScript code
    (`tools/analytics/retention.ts`).

    *   **State (Private)**: The Database Connection (`DATABASE_URL`).


    ## 5.2 Hub & Spoke Topology (Git Backed)

    Because TGP relies on Git, your tools are portable.

    *   **Upstream**: A private repo (e.g., `github.com/org/tgp-global`).

    *   **Downstream**: The ephemeral serverless instances pull from Upstream.


    ---


    # 6. Governance Modes


    ## 6.1 God Mode (Development)

    *   **Behavior**: `Forge -> Compile -> Execute`.

    *   **Target**: Local `.tgp/` folder or direct push to `main`.


    ## 6.2 Gatekeeper Mode (Production)

    *   **Behavior**: `Forge -> Compile -> Pull Request`.

    *   **Target**: Agent creates a branch `feat/tool-name` and opens a PR.

    *   **Approval**: A human or a Senior Agent reviews the diff before merging
    to `main`.


    ---


    # 7. Integration Spec


    ## 7.1 The Bootstrap

    ```bash

    npx tgp@latest init

    ```


    ## 7.2 Configuration (`tgp.config.ts`)


    The configuration defines the Sandbox boundaries and the Git backend.


    ```typescript

    import { defineTGPConfig } from '@tgp/core';


    export default defineTGPConfig({
      // The Root of the Agent's filesystem (Ephemeral in serverless)
      rootDir: './.tgp',
      // NOTE: The 'db' and 'fs' sections below are METADATA for the Agent.
      // The actual database and filesystem permissions must be injected at runtime.

      // 1. DATA: How the Agent sees your DB
      db: {
        dialect: 'postgres',
        ddlSource: 'drizzle-kit generate --print',
      },

      // 2. BACKEND (GitOps)
      // Essential for Serverless/Ephemeral environments.
      // The Agent pulls state from here and pushes new tools here.
      git: {
        provider: 'github', // or 'gitlab', 'bitbucket'
        repo: 'my-org/tgp-tools',
        branch: 'main',
        auth: {
          // Why not in config? Because we read from ENV for security.
          token: process.env.TGP_GITHUB_TOKEN,
          user: 'tgp-bot[bot]',
          email: 'tgp-bot@users.noreply.github.com'
        },
        // Strategy: 'direct' (push) or 'pr' (pull request)
        writeStrategy: process.env.NODE_ENV === 'production' ? 'pr' : 'direct'
      },

      // 3. FILESYSTEM JAIL
      fs: {
        allowedDirs: ['./public/exports', './tmp'],
        blockUpwardTraversal: true
      },

      // 4. RUNTIME
      allowedImports: ['@tgp/std', 'zod', 'date-fns']
    });

    ```


    ## 7.3 Runtime Usage (The SDK)


    ```typescript

    // src/app/api/agent/route.ts

    import { TGP, tgpTools } from '@tgp/core';

    import { generateText } from 'ai';


    const kernel = new TGP({ configFile: './tgp.config.ts' });


    export async function POST(req: Request) {
      const { messages } = await req.json();

      // Injects: list_files, read_file, write_file, exec_tool
      const tools = tgpTools(kernel);

      const result = await generateText({
        model: openai('gpt-4-turbo'),
        tools, 
        messages,
        // The System Prompt enforces the "8 Standards"
        system: kernel.getSystemPrompt() 
      });

      return result.response;
    }

    ```


    ---


    # 8. Roadmap & Contributing


    We are hacking on the future of backend development.


    *   **[P0] The LSP**: IDE extension for real-time tool visibility.

    *   **[P1] Vector Memory**: Semantic search for tool reuse.

    *   **[P2] Multi-Lang**: Python support via WebAssembly.


    **Get Involved:**

    `git clone` -> `npm install` -> `npm run forge`.

    ```
  src/tgp.ts: >-
    import * as fs from 'node:fs';

    import * as http from 'isomorphic-git/http/node';

    import { createKernel, Kernel, KernelEnvironment } from './kernel/core.js';

    import { loadTGPConfig } from './config.js';

    import { createNodeVFS } from './vfs/node.js';

    import { TGPConfigSchema, TGPConfig, Logger, DBBackend } from './types.js';

    import { VFSAdapter } from './vfs/types.js';

    import { GitBackend } from './kernel/git.js';

    import { Registry } from './kernel/registry.js';


    export interface TGPOptions {
      /**
       * Path to the configuration file.
       * @default "./tgp.config.ts"
       */
      configFile?: string;

      /**
       * Override the Virtual Filesystem Adapter.
       * Useful for using MemoryVFS in tests or Edge environments.
       * If omitted, defaults to NodeVFS rooted at config.rootDir.
       */
      vfs?: VFSAdapter;

      /**
       * Inject a custom logger. Defaults to console.
       */
      logger?: Logger;

      /**
       * Inject a custom Database Backend.
       */
      db?: DBBackend;

      /**
       * Override the raw filesystem used by Git.
       * If omitted, defaults to 'node:fs'.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      fs?: any;

      /**
       * Override the HTTP client used by Git.
       * If omitted, defaults to 'isomorphic-git/http/node'.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      http?: any;
    }


    /**
     * The TGP Kernel Class.
     * Manages the lifecycle of the Agent's runtime environment, including
     * configuration, filesystem (VFS), Git persistence, and the Tool Registry.
     */
    export class TGP implements Kernel {
      public config: TGPConfig;
      public vfs: VFSAdapter;
      public git: GitBackend;
      public db: DBBackend;
      public registry: Registry;
      public logger: Logger;
      
      private _isBooted = false;

      constructor(private opts: TGPOptions = {}) {
        // 1. Initialize with Defaults (Sync)
        // We use the default schema to ensure the kernel is usable immediately (e.g. for tooling)
        // even before the async config load completes.
        this.config = TGPConfigSchema.parse({});
        
        // 2. Setup VFS
        // Use injected VFS or default to Node VFS
        this.vfs = opts.vfs || createNodeVFS(this.config.rootDir);

        // 3. Initialize Kernel Components
        // Construct Environment with defaults if not provided
        const env: KernelEnvironment = {
          fs: opts.fs || fs,
          http: opts.http || http
        };

        const kernel = createKernel({
          config: this.config,
          vfs: this.vfs,
          env,
          logger: opts.logger,
          db: opts.db
        });

        this.git = kernel.git;
        this.db = kernel.db;
        this.registry = kernel.registry;
        this.logger = kernel.logger;
      }

      /**
       * Hydrates the Kernel from the configuration file and Git.
       * This must be awaited before executing tools in production.
       */
      async boot(): Promise<void> {
        if (this._isBooted) return;

        const configPath = this.opts.configFile || './tgp.config.ts';

        try {
          // 1. Load Real Configuration
          const loadedConfig = await loadTGPConfig(configPath);
          this.config = loadedConfig;

          // 2. Re-initialize VFS if RootDir changed AND user didn't inject a custom VFS
          // If the user injected a VFS, we assume they configured it correctly.
          if (!this.opts.vfs) {
            this.vfs = createNodeVFS(this.config.rootDir);
          }

          // 3. Re-initialize Kernel Components with new Config/VFS
          const env: KernelEnvironment = {
            fs: this.opts.fs || fs,
            http: this.opts.http || http
          };

          const kernel = createKernel({
            config: this.config,
            vfs: this.vfs,
            env,
            logger: this.opts.logger,
            db: this.opts.db
          });
          
          this.git = kernel.git;
          this.db = kernel.db;
          this.registry = kernel.registry;

          // 4. Hydrate State (Git Clone/Pull + Registry Build)
          await kernel.boot();
          
          this._isBooted = true;
        } catch (error) {
          // If config loading fails, we might still be in a valid default state,
          // but we should warn the user.
          console.warn(`[TGP] Boot warning:`, error);
          throw error;
        }
      }

      async shutdown(): Promise<void> {
        // Passthrough to internal kernel shutdown if needed
        this._isBooted = false;
      }

      /**
       * Generates the System Prompt enforcing the "8 Standards" and TGP protocol.
       */
      getSystemPrompt(): string {
        return `
    You are an autonomous AI Engineer running on the Tool Generation Protocol
    (TGP).

    Your goal is to build, validate, and execute tools to solve the user's
    request.


    # THE PROTOCOL


    1.  **Reuse or Forge**: Check if a tool exists. If not, write it.

    2.  **No One-Offs**: Do not execute arbitrary scripts. Create a reusable
    tool in 'tools/'.

    3.  **Strict Typing**: All tools must be written in TypeScript. No 'any', no
    'unknown'.


    # CODING STANDARDS (The 8 Commandments)


    1.  **Abstract**: Logic must be separated from data. (e.g., args.taxRate,
    not 0.05).

    2.  **Composable**: Functions should return results usable by others.

    3.  **HOFs**: Use map/reduce/filter over imperative loops.

    4.  **Stateless**: No global state. No reliance on previous execution.

    5.  **Reusable**: Generic enough for multiple use cases.

    6.  **General by Params**: Behavior controlled by arguments.

    7.  **No Hardcoded Values**: No magic numbers or IDs.

    8.  **Orchestrator**: Tools can import other tools via 'require'.


    # EXECUTION FLOW


    1.  List files to see what you have.

    2.  Read file content to understand the tool.

    3.  If missing, write_file to create a new tool.

    4.  Use check_tool to validate syntax.

    5.  Use exec_tool to run it.

    `;
      }
    }


    /**
     * Legacy Factory to create a TGP Kernel (Backward Compatibility).
     */
    export async function createTGP(opts: TGPOptions = {}): Promise<Kernel> {
      const tgp = new TGP(opts);
      await tgp.boot();
      return tgp;
    }


    /**
     * Helper to get the system prompt (Backward Compatibility).
     */
    export function getSystemPrompt(): string {
      return new TGP().getSystemPrompt();
    }
  package.json: |
    {
      "name": "@tgp/core",
      "version": "0.0.1",
      "description": "The Tool Generation Protocol",
      "main": "dist/index.js",
      "types": "dist/index.d.ts",
      "type": "module",
      "scripts": {
        "build": "tsc",
        "lint": "eslint src/**/*.ts",
        "lint:fix": "eslint src/**/*.ts --fix",
        "test": "echo \"Error: no test specified\" && exit 1",
        "tgp": "node bin/tgp.js"
      },
      "keywords": [
        "ai",
        "agent",
        "protocol",
        "backend"
      ],
      "author": "",
      "license": "MIT",
      "bin": {
        "tgp": "./bin/tgp.js"
      },
      "dependencies": {
        "esbuild": "^0.19.12",
        "isolated-vm": "^6.0.2",
        "isomorphic-git": "^1.35.1",
        "zod": "^3.25.76",
        "zod-to-json-schema": "^3.22.4"
      },
      "devDependencies": {
        "@types/node": "^20.19.25",
        "@typescript-eslint/eslint-plugin": "^8.48.0",
        "@typescript-eslint/parser": "^8.48.0",
        "eslint": "^9.39.1",
        "typescript": "^5.9.3"
      }
    }
  src/sandbox/bridge.ts: >-
    /* eslint-disable no-console */

    import { Kernel } from '../kernel/core.js';

    import * as path from 'path';


    export interface SandboxBridgeOptions {
      kernel: Pick<Kernel, 'vfs' | 'config'>;
      onLog?: (message: string) => void;
    }


    /**
     * Creates the Bridge Object exposed to the Sandbox.
     * This maps secure Kernel methods to the Guest environment.
     * 
     * We expose a structured 'tgp' object to the guest.
     */
    export function createSandboxBridge({ kernel, onLog }: SandboxBridgeOptions)
    {
      const { vfs, config } = kernel;
      const { allowedDirs } = config.fs;

      const isAllowedWrite = (target: string): boolean => {
        // Normalize target to ensure clean comparison (remove leading ./, etc)
        const normalizedTarget = path.normalize(target).replace(/^(\.\/)/, '');
        
        return allowedDirs.some(dir => {
          const normalizedDir = path.normalize(dir).replace(/^(\.\/)/, '');
          // Check if target is inside the allowed dir
          return normalizedTarget.startsWith(normalizedDir);
        });
      };

      return {
        tgp: {
          // --- Filesystem Bridge (Jailed) ---
          read_file: async (path: string) => {
            return vfs.readFile(path);
          },

          write_file: async (path: string, content: string) => {
            if (!isAllowedWrite(path)) {
              throw new Error(`Security Violation: Write access denied for '${path}'. Allowed directories: ${allowedDirs.join(', ')}`);
            }
            return vfs.writeFile(path, content);
          },

          list_files: async (dir: string) => {
            return vfs.listFiles(dir, false);
          },

          // --- Network Bridge (Allowed Only) ---
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          fetch: async (url: string, init?: any) => {
            // Security: Parse URL and allow-list check could happen here
            const response = await fetch(url, init);
            const text = await response.text();
            return {
              status: response.status,
              text: () => text,
              json: () => JSON.parse(text),
            };
          },

          // --- Logger ---
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          log: (...args: any[]) => {
            const msg = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
            if (onLog) {
                onLog(msg);
            } else {
                console.log('[TGP-TOOL]', msg);
            }
          }
        }
      };
    }
  export interface Kernel {: |2-
      boot(): Promise<void>;
      shutdown(): Promise<void>;
      config: TGPConfig;
      vfs: VFSAdapter;
      git: GitBackend;
      db: DBBackend;
      registry: Registry;
    }
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 31

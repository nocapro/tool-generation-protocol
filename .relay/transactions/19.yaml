uuid: c88d77d1-9257-4b11-b0e6-54d19335f6a2
projectId: tool-generation-protocol
createdAt: '2025-11-27T11:04:18.487Z'
gitCommitMsg: >-
  refactor: replace TGP class with createTGP factory

  Converts the TGP kernel class into a functional closure to align with the
  'no-classes' architectural guideline.
promptSummary: >-
  Refactor codebase to remove classes and usage of OOP in favor of HOFs and
  factory functions, specifically replacing TGP class with createTGP.
reasoning:
  - >-
    Refactoring the codebase to use Higher-Order Functions (HOFs) and Factory
    functions instead of Object-Oriented classes. This aligns the `TGP` kernel
    creation with the rest of the codebase which already uses factories
    (`createKernel`, `createGitBackend`, etc.).
  - '1.  **Refactor `src/tgp.ts`**:'
  - '*   Removed `class TGP`.'
  - >-
    *   Implemented `createTGP(opts)` as a factory function that holds state
    (`config`, `vfs`, `kernel`) in a closure.
  - >-
    *   The returned object exposes the `Kernel` interface via getters that
    access the current state in the closure (handling re-initialization during
    `boot`).
  - >-
    *   Renamed the existing async `createTGP` to `bootTGP` (as a utility) and
    made `createTGP` the primary synchronous factory (replacing `new TGP()`).
  - '2.  **Update `README.md`**:'
  - '*   Updated usage examples to use `createTGP` instead of `new TGP`.'
  - typescript
  - // src/app/api/agent/route.ts
  - '-import { TGP, tgpTools } from ''@tgp/core'';'
  - +import { createTGP, tgpTools } from '@tgp/core';
  - import { generateText } from 'ai';
  - '-const kernel = new TGP({ configFile: ''./tgp.config.ts'' });'
  - '+const kernel = createTGP({ configFile: ''./tgp.config.ts'' });'
  - 'export async function POST(req: Request) {'
  - const { messages } = await req.json();
  - '// Injects: list_files, read_file, write_file, exec_tool'
  - const tools = tgpTools(kernel);
  - '```'
operations:
  - type: write
    path: src/tgp.ts
    content: >-
      import * as fs from 'node:fs';

      import { createKernel, Kernel } from './kernel/core.js';

      import { loadTGPConfig } from './config.js';

      import { createNodeVFS } from './vfs/node.js';

      import { TGPConfigSchema } from './types.js';


      export interface TGPOptions {
        /**
         * Path to the configuration file.
         * @default "./tgp.config.ts"
         */
        configFile?: string;
      }


      /**
       * The TGP Kernel Interface extended with system prompt generation.
       */
      export interface TGPKernel extends Kernel {
        getSystemPrompt(): string;
      }


      const SYSTEM_PROMPT = `

      You are an autonomous AI Engineer running on the Tool Generation Protocol
      (TGP).

      Your goal is to build, validate, and execute tools to solve the user's
      request.


      # THE PROTOCOL


      1.  **Reuse or Forge**: Check if a tool exists. If not, write it.

      2.  **No One-Offs**: Do not execute arbitrary scripts. Create a reusable
      tool in 'tools/'.

      3.  **Strict Typing**: All tools must be written in TypeScript. No 'any',
      no 'unknown'.


      # CODING STANDARDS (The 8 Commandments)


      1.  **Abstract**: Logic must be separated from data. (e.g., args.taxRate,
      not 0.05).

      2.  **Composable**: Functions should return results usable by others.

      3.  **HOFs**: Use map/reduce/filter over imperative loops.

      4.  **Stateless**: No global state. No reliance on previous execution.

      5.  **Reusable**: Generic enough for multiple use cases.

      6.  **General by Params**: Behavior controlled by arguments.

      7.  **No Hardcoded Values**: No magic numbers or IDs.

      8.  **Orchestrator**: Tools can import other tools via 'require'.


      # EXECUTION FLOW


      1.  List files to see what you have.

      2.  Read file content to understand the tool.

      3.  If missing, write_file to create a new tool.

      4.  Use check_tool to validate syntax.

      5.  Use exec_tool to run it.

      `;


      /**
       * Creates the TGP Kernel.
       * Manages the lifecycle of the Agent's runtime environment, including
       * configuration, filesystem (VFS), Git persistence, and the Tool Registry.
       */
      export function createTGP(opts: TGPOptions = {}): TGPKernel {
        // 1. Initialize with Defaults (Sync)
        // We use the default schema to ensure the kernel is usable immediately (e.g. for tooling)
        // even before the async config load completes.
        let config = TGPConfigSchema.parse({});
        
        // 2. Setup Default VFS
        // This allows tgpTools(kernel) to be called immediately.
        let vfs = createNodeVFS(config.rootDir);

        // 3. Initialize Kernel Components
        // We use the underlying factory to wire up Git, DB, and Registry
        let kernel = createKernel({
          config,
          vfs,
          fs // Pass raw node:fs for isomorphic-git
        });

        let isBooted = false;

        const boot = async () => {
          if (isBooted) return;

          const configPath = opts.configFile || './tgp.config.ts';

          try {
            // 1. Load Real Configuration
            const loadedConfig = await loadTGPConfig(configPath);
            config = loadedConfig;

            // 2. Re-initialize VFS if RootDir changed
            // If the user configured a different rootDir, we must update the VFS.
            vfs = createNodeVFS(config.rootDir);

            // 3. Re-initialize Kernel Components with new Config/VFS
            kernel = createKernel({
              config,
              vfs,
              fs
            });
            
            // 4. Hydrate State (Git Clone/Pull + Registry Build)
            await kernel.boot();
            
            isBooted = true;
          } catch (error) {
            // If config loading fails, we might still be in a valid default state,
            // but we should warn the user.
            console.warn(`[TGP] Boot warning:`, error);
            throw error;
          }
        };

        const shutdown = async () => {
          // Passthrough to internal kernel shutdown if needed
          await kernel.shutdown();
          isBooted = false;
        };

        const getSystemPrompt = () => SYSTEM_PROMPT;

        // We return getters to ensure we always access the latest 'kernel' instance
        // stored in the closure variables (since 'kernel' variable is reassigned during boot).
        return {
          boot,
          shutdown,
          getSystemPrompt,
          get config() { return kernel.config; },
          get vfs() { return kernel.vfs; },
          get git() { return kernel.git; },
          get db() { return kernel.db; },
          get registry() { return kernel.registry; },
        };
      }


      /**
       * Legacy Helper to create and boot a TGP Kernel.
       */
      export async function bootTGP(opts: TGPOptions = {}): Promise<TGPKernel> {
        const tgp = createTGP(opts);
        await tgp.boot();
        return tgp;
      }


      /**
       * Helper to get the system prompt.
       */
      export function getSystemPrompt(): string {
        return createTGP().getSystemPrompt();
      }
    patchStrategy: replace
  - type: write
    path: README.md
    content: |-
      --- README.md
      +++ README.md
      @@ -176,13 +176,13 @@
       
       
    patchStrategy: standard-diff
snapshot:
  src/tgp.ts: >-
    import * as fs from 'node:fs';

    import { createKernel, Kernel } from './kernel/core.js';

    import { loadTGPConfig } from './config.js';

    import { createNodeVFS } from './vfs/node.js';

    import { TGPConfigSchema, TGPConfig } from './types.js';

    import { VFSAdapter } from './vfs/types.js';

    import { GitBackend } from './kernel/git.js';

    import { DBBackend } from './kernel/db.js';

    import { Registry } from './kernel/registry.js';


    export interface TGPOptions {
      /**
       * Path to the configuration file.
       * @default "./tgp.config.ts"
       */
      configFile?: string;
    }


    /**
     * The TGP Kernel Class.
     * Manages the lifecycle of the Agent's runtime environment, including
     * configuration, filesystem (VFS), Git persistence, and the Tool Registry.
     */
    export class TGP implements Kernel {
      public config: TGPConfig;
      public vfs: VFSAdapter;
      public git: GitBackend;
      public db: DBBackend;
      public registry: Registry;
      
      private _isBooted = false;

      constructor(private opts: TGPOptions = {}) {
        // 1. Initialize with Defaults (Sync)
        // We use the default schema to ensure the kernel is usable immediately (e.g. for tooling)
        // even before the async config load completes.
        this.config = TGPConfigSchema.parse({});
        
        // 2. Setup Default VFS
        // This allows tgpTools(kernel) to be called immediately.
        this.vfs = createNodeVFS(this.config.rootDir);

        // 3. Initialize Kernel Components
        // We use the underlying factory to wire up Git, DB, and Registry
        const kernel = createKernel({
          config: this.config,
          vfs: this.vfs,
          fs // Pass raw node:fs for isomorphic-git
        });

        this.git = kernel.git;
        this.db = kernel.db;
        this.registry = kernel.registry;
      }

      /**
       * Hydrates the Kernel from the configuration file and Git.
       * This must be awaited before executing tools in production.
       */
      async boot(): Promise<void> {
        if (this._isBooted) return;

        const configPath = this.opts.configFile || './tgp.config.ts';

        try {
          // 1. Load Real Configuration
          const loadedConfig = await loadTGPConfig(configPath);
          this.config = loadedConfig;

          // 2. Re-initialize VFS if RootDir changed
          // If the user configured a different rootDir, we must update the VFS.
          this.vfs = createNodeVFS(this.config.rootDir);

          // 3. Re-initialize Kernel Components with new Config/VFS
          const kernel = createKernel({
            config: this.config,
            vfs: this.vfs,
            fs
          });
          
          this.git = kernel.git;
          this.db = kernel.db;
          this.registry = kernel.registry;

          // 4. Hydrate State (Git Clone/Pull + Registry Build)
          await kernel.boot();
          
          this._isBooted = true;
        } catch (error) {
          // If config loading fails, we might still be in a valid default state,
          // but we should warn the user.
          console.warn(`[TGP] Boot warning:`, error);
          throw error;
        }
      }

      async shutdown(): Promise<void> {
        // Passthrough to internal kernel shutdown if needed
        this._isBooted = false;
      }

      /**
       * Generates the System Prompt enforcing the "8 Standards" and TGP protocol.
       */
      getSystemPrompt(): string {
        return `
    You are an autonomous AI Engineer running on the Tool Generation Protocol
    (TGP).

    Your goal is to build, validate, and execute tools to solve the user's
    request.


    # THE PROTOCOL


    1.  **Reuse or Forge**: Check if a tool exists. If not, write it.

    2.  **No One-Offs**: Do not execute arbitrary scripts. Create a reusable
    tool in 'tools/'.

    3.  **Strict Typing**: All tools must be written in TypeScript. No 'any', no
    'unknown'.


    # CODING STANDARDS (The 8 Commandments)


    1.  **Abstract**: Logic must be separated from data. (e.g., args.taxRate,
    not 0.05).

    2.  **Composable**: Functions should return results usable by others.

    3.  **HOFs**: Use map/reduce/filter over imperative loops.

    4.  **Stateless**: No global state. No reliance on previous execution.

    5.  **Reusable**: Generic enough for multiple use cases.

    6.  **General by Params**: Behavior controlled by arguments.

    7.  **No Hardcoded Values**: No magic numbers or IDs.

    8.  **Orchestrator**: Tools can import other tools via 'require'.


    # EXECUTION FLOW


    1.  List files to see what you have.

    2.  Read file content to understand the tool.

    3.  If missing, write_file to create a new tool.

    4.  Use check_tool to validate syntax.

    5.  Use exec_tool to run it.

    `;
      }
    }


    /**
     * Legacy Factory to create a TGP Kernel (Backward Compatibility).
     */
    export async function createTGP(opts: TGPOptions = {}): Promise<Kernel> {
      const tgp = new TGP(opts);
      await tgp.boot();
      return tgp;
    }


    /**
     * Helper to get the system prompt (Backward Compatibility).
     */
    export function getSystemPrompt(): string {
      return new TGP().getSystemPrompt();
    }
  README.md: >
    # Tool Generation Protocol (TGP)


    > **The Self-Assembling Backend.**

    > **MCP is dead.** Stop streaming context. Start compiling tools.


    # 1. Manifesto


    **The Problem:** You spend 80% of your time writing "glue code"—RPCs, CRUD
    wrappers, and slightly different "Export to CSV" endpoints.

    **The Trap (MCP):** Model Context Protocol (MCP) is just better glue. It
    requires you to pre-build tools. If you didn't write the endpoint, the Agent
    fails.

    **The Solution (TGP):** Give the Agent a compiler.


    TGP is a **JIT Runtime for Business Logic**. The Agent forges its own tools,
    validates them, and persists them to Git. It builds a personalized standard
    library for your application.


    *   **MCP**: "I can't do that. I don't have a tool."

    *   **TGP**: "I wrote a tool. It's running."


    ## 1.1 Use Cases (The Long Tail)


    99% of features are never built because they are too specific. TGP solves
    the "I wish the app could do X" problem.


    *   **Reporting**: "List users who downgraded in June, pipe-delimited." ->
    Forges `tools/reports/downgrade.ts`. Time: 4s.

    *   **Cleanup**: "Fix typo in 'Ohiio' for active users." -> Forges
    `tools/maintenance/fix_typo.ts`. Atomic SQL update.

    *   **Logic**: "Calculate dimensional weight `(L*W*H)/139`." -> Forges
    `tools/shipping/dim_weight.ts`. Deterministic V8 execution.


    ## 1.2 Anti-Patterns


    TGP is a **JIT Compiler**, not a Daemon.

    *   **Not a Server**: No `express.listen()`. Tools are ephemeral
    (Lambda-style).

    *   **Not a Browser**: No DOM. No Puppeteer.

    *   **Not an ORM**: No object mutation. Use raw, atomic SQL.


    # 2. Architecture (The Stack)


    TGP drops into your existing Node/Next.js/Nest apps. It is **just
    TypeScript**.


    ## 2.1 The Developer View


    The agent views `./.tgp` as its root directory. This is a standard Git
    repository.


    ```bash

    ./.tgp/

    ├── .git/                  # MEMORY: Version history of TOOL SOURCE CODE.

    ├── bin/                   # KERNEL: The compiled 'tgp' binary.

    ├── tools/                 # USER SPACE: Generated capabilities.

    │   ├── analytics/         # e.g., "churn-prediction.ts"

    │   └── reports/           # e.g., "revenue-csv.ts"

    └── meta.json              # REGISTRY: Fast lookup index.

    ```


    ## 2.2 GitOps & Serverless Harmony


    **Is TGP Serverless Friendly?** Yes.


    In a Serverless environment (Cloudflare Workers, AWS Lambda, Vercel), the
    runtime filesystem is ephemeral. TGP handles this by treating **Git as the
    Backend**.


    1.  **Hydration**: On boot, TGP checks if the local cache matches the remote
    `HEAD`. If not, it pulls the latest tools from GitHub/GitLab.

    2.  **Execution**: Tools run in the local V8 Isolate (milliseconds).

    3.  **Persistence**: When an Agent forges a new tool, it commits and pushes
    to the remote repository.

    4.  **Concurrency**: TGP uses standard Git locking to handle concurrent
    writes from multiple agents.


    *Configuring GitHub credentials enables the "Infinite Memory" feature.*


    ## 2.3 The VFS (Virtual Filesystem)


    TGP enforces a strict separation between **The Editor (Host)** and **The
    Runtime (Sandbox)**.


    1.  **The Editor (Agent Context)**: The Agent accesses `./.tgp` directly via
    the Kernel Tools. It works just like a human dev using VS Code.

    2.  **The Runtime (Sandbox Context)**: When code *executes*, it runs inside
    the V8 Isolate with a restricted VFS:
        *   **`/lib`**: Read-Only mount of Host's `./.tgp/tools`.
        *   **`/tmp`**: Read-Write ephemeral scratchpad (wiped on exit).

    ## 2.4 The Kernel Tools (Agent Capabilities)


    The Agent is provided with a specific set of primitives to interact with the
    environment. It does not have generic shell access.


    | Tool | Signature | Description |

    | :--- | :--- | :--- |

    | **`list_files`** | `(dir: string) => string[]` | Recursively list
    available tools or definitions. |

    | **`read_file`** | `(path: string) => string` | Read the content of an
    existing tool or schema. |

    | **`write_file`** | `(path: string, content: string) => void` | Create a
    new tool or overwrite a draft. |

    | **`patch_file`** | `(path: string, search: string, replace: string) =>
    void` | Surgical search-and-replace for refactoring. |

    | **`check_tool`** | `(path: string) => { valid: boolean, errors: string[]
    }` | Run the JIT compiler and linter. |

    | **`exec_tool`** | `(path: string, args: object) => any` | Execute a tool
    inside the secure Sandbox. |


    ---


    # 3. The Protocol


    This is the algorithm the Agent must follow. It is the "software" running on
    the Agent's "CPU".


    ## 3.1 The Prime Directive: "Reuse or Forge"


    The Agent is forbidden from executing one-off scripts for repetitive tasks.


    1.  **Lookup**: Query registry. If a tool exists (Score > 0.85), **Reuse**.

    2.  **Forge**: If no tool exists, **Create**.

    3.  **Persist**: Commit to Git.


    ## 3.2 The 8 Standards of Code Quality


    To ensure the ecosystem remains clean, the Agent must adhere to strict code
    quality guidelines. The Linter/Reviewer will reject tools that violate these
    principles.


    1.  **Abstract**: Logic must be separated from specific data instances.
        *   *Bad*: `const tax = 0.05`
        *   *Good*: `const tax = args.taxRate`
    2.  **Composable**: Functions should do one thing and return a result usable
    by other functions.

    3.  **HOFs (Higher Order Functions)**: Use map/reduce/filter patterns rather
    than imperative loops where possible.

    4.  **Stateless**: Tools must not rely on variables outside their scope or
    previous executions.

    5.  **Reusable**: The code should be generic enough to serve multiple use
    cases.

    6.  **General by Params**: Behavior is controlled by arguments, not
    hardcoded strings.

    7.  **No Hardcoded Values**: No magic numbers, no specific IDs, no emails in
    source code.

    8.  **Orchestrator Capable**: Tools should be able to import and invoke
    other TGP tools (via the `require` bridge).


    ## 3.3 The Feedback Loop (Self-Healing)


    If a tool fails during execution:

    1.  **Capture**: Agent reads STDERR.

    2.  **Diagnose**: Agent identifies the logic error or schema mismatch.

    3.  **Patch**: Agent uses `patch_file` to fix the code in place.

    4.  **Verify**: Agent runs `check_tool`.


    ---


    # 4. Security (The Sandbox)


    **TL;DR:**

    1.  **Zero-Trust**: Tools run in a stripped V8 context. No `process`, no
    `fs`, no `eval`.

    2.  **Resource Caps**: 64MB RAM, 50ms CPU time. Infinite loops die
    instantly.

    3.  **Transaction Safety**: All DB writes run inside a transaction. If the
    tool throws, the DB rolls back.


    ## 4.1 The Great Wall (isolated-vm)

    TGP uses `isolated-vm` to create a boundary between the Host (Agent) and the
    Guest (Tool).

    *   **Memory**: Separate Heaps.

    *   **Syscalls**: Bridged via specific `tgp` global object.

    *   **Network**: Blocked by default. Allowed only via whitelisted `fetch`
    bridge.


    ---


    # 5. The Ecosystem (Join the Hive)


    We are building the **`libc` of the AI Age**.


    ## 5.1 The Logic/State Split

    In TGP, **Tools are Stateless**.

    *   **Logic (Public)**: The TypeScript code
    (`tools/analytics/retention.ts`).

    *   **State (Private)**: The Database Connection (`DATABASE_URL`).


    ## 5.2 Hub & Spoke Topology (Git Backed)

    Because TGP relies on Git, your tools are portable.

    *   **Upstream**: A private repo (e.g., `github.com/org/tgp-global`).

    *   **Downstream**: The ephemeral serverless instances pull from Upstream.


    ---


    # 6. Governance Modes


    ## 6.1 God Mode (Development)

    *   **Behavior**: `Forge -> Compile -> Execute`.

    *   **Target**: Local `.tgp/` folder or direct push to `main`.


    ## 6.2 Gatekeeper Mode (Production)

    *   **Behavior**: `Forge -> Compile -> Pull Request`.

    *   **Target**: Agent creates a branch `feat/tool-name` and opens a PR.

    *   **Approval**: A human or a Senior Agent reviews the diff before merging
    to `main`.


    ---


    # 7. Integration Spec


    ## 7.1 The Bootstrap

    ```bash

    npx tgp@latest init

    ```


    ## 7.2 Configuration (`tgp.config.ts`)


    The configuration defines the Sandbox boundaries and the Git backend.


    ```typescript

    import { defineTGPConfig } from '@tgp/core';


    export default defineTGPConfig({
      // The Root of the Agent's filesystem (Ephemeral in serverless)
      rootDir: './.tgp',

      // 1. DATA: How the Agent sees your DB
      db: {
        dialect: 'postgres',
        ddlSource: 'drizzle-kit generate --print',
      },

      // 2. BACKEND (GitOps)
      // Essential for Serverless/Ephemeral environments.
      // The Agent pulls state from here and pushes new tools here.
      git: {
        provider: 'github', // or 'gitlab', 'bitbucket'
        repo: 'my-org/tgp-tools',
        branch: 'main',
        auth: {
          // Why not in config? Because we read from ENV for security.
          token: process.env.TGP_GITHUB_TOKEN,
          user: 'tgp-bot[bot]',
          email: 'tgp-bot@users.noreply.github.com'
        },
        // Strategy: 'direct' (push) or 'pr' (pull request)
        writeStrategy: process.env.NODE_ENV === 'production' ? 'pr' : 'direct'
      },

      // 3. FILESYSTEM JAIL
      fs: {
        allowedDirs: ['./public/exports', './tmp'],
        blockUpwardTraversal: true
      },

      // 4. RUNTIME
      allowedImports: ['@tgp/std', 'zod', 'date-fns']
    });

    ```


    ## 7.3 Runtime Usage (The SDK)


    ```typescript

    // src/app/api/agent/route.ts

    import { TGP, tgpTools } from '@tgp/core';

    import { generateText } from 'ai';


    const kernel = new TGP({ configFile: './tgp.config.ts' });


    export async function POST(req: Request) {
      const { messages } = await req.json();

      // Injects: list_files, read_file, write_file, exec_tool
      const tools = tgpTools(kernel);

      const result = await generateText({
        model: openai('gpt-4-turbo'),
        tools, 
        messages,
        // The System Prompt enforces the "8 Standards"
        system: kernel.getSystemPrompt() 
      });

      return result.response;
    }

    ```


    ---


    # 8. Roadmap & Contributing


    We are hacking on the future of backend development.


    *   **[P0] The LSP**: IDE extension for real-time tool visibility.

    *   **[P1] Vector Memory**: Semantic search for tool reuse.

    *   **[P2] Multi-Lang**: Python support via WebAssembly.


    **Get Involved:**

    `git clone` -> `npm install` -> `npm run forge`.

    ```
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 19
